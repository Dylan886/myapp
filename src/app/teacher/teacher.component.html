<nz-layout class="layout">
  <nz-header>
    <div class="logo">{{username}}</div>
    <ul nz-menu [nzTheme]="'dark'" [nzMode]="'horizontal'" style="line-height: 64px;">
      <li nz-menu-item (click)="MODE ='main'">主页</li>
      <li nz-menu-item (click)="MODE ='addition';Sider='1'">知识点学习</li>
      <li nz-menu-item (click)="MODE ='advanced'">拓展知识</li>
      <li nz-menu-item (click)="MODE ='fundament';Sider='1'">集合框架</li>
      <li nz-menu-item (click)="MODE ='resource'">相关资源</li>
      <li nz-menu-item (click)="MODE ='exam';this.getExam();this.getTestPaper()">在线测试</li>
      <li nz-menu-item *ngIf="this.user.type !== '游客'" (click)="Pvisible=true">修改密码</li>
      <li nz-menu-item *ngIf="this.user.type !== '游客'" (click)="logout()">注销</li>
      <li nz-menu-item *ngIf="this.user.type === '游客'" (click)="logout()">登陆</li>
      <li nz-menu-item *ngIf="this.user.type === 'admin'" ><a routerLink="../admin">管理中心</a></li>
    </ul>
  </nz-header>

  <nz-layout style="margin: 30px 20px 30px 20px">

    <!--// 侧边栏-->
    <nz-sider [nzWidth]="200" style="background:#fff">

      <!--知识点的侧边栏-->
      <div *ngIf="MODE == 'addition'">
        <ul nz-menu [nzMode]="'inline'" style="height:100%">
          <li nz-submenu>
            <span title><i nz-icon type="user"></i>JAVA基础</span>
            <ul>
              <li nz-menu-item (click)="Sider ='1'">Java简介</li>
              <li nz-menu-item (click)="Sider ='2'">Java基本数据类型</li>
              <li nz-menu-item (click)="Sider ='3'">Java 变量类型</li>
            </ul>
          </li>
          <li nz-submenu>
            <span title><i nz-icon type="user"></i>JAVA三大特性</span>
            <ul>
              <li nz-menu-item (click)="Sider ='4'">Java继承</li>
              <li nz-menu-item (click)="Sider ='5'">Java多态</li>
              <li nz-menu-item (click)="Sider ='6'">Java封装</li>
            </ul>
          </li>
          <li nz-submenu>
            <span title><i nz-icon type="user"></i>JAVA算法</span>
            <ul>
              <li nz-menu-item (click)="Sider ='7'">分治法</li>
              <li nz-menu-item (click)="Sider ='8'">贪心算法</li>
              <li nz-menu-item (click)="Sider ='9'">动态规划算法</li>
              <li nz-menu-item (click)="Sider ='10'">回溯法</li>
              <li nz-menu-item (click)="Sider ='11'">分支限界法</li>
            </ul>
          </li>
          <li nz-submenu>
            <span title><i nz-icon type="user"></i>JAVA设计模式</span>
            <ul>
              <li nz-menu-item (click)="Sider ='12'">Java继承</li>
              <li nz-menu-item (click)="Sider ='13'">Java多态</li>
              <li nz-menu-item (click)="Sider ='14'">Java封装</li>
            </ul>
          </li>
        </ul>
      </div>

      <!--拓展知识的侧边栏-->
      <div *ngIf="MODE == 'advanced'">
        <!--提取知识点的名称，并push入侧边栏 "> </div>-->
        <ul nz-menu [nzMode]="'inline'" style="height:100%">
          <li nz-menu-item *ngFor="let s of this.sider" ><p (click)="changeSelected(s)">{{s}}</p>></li>
        </ul>
      </div>

      <!--集合框架的侧边栏-->
      <div *ngIf="MODE == 'fundament'">
        <ul nz-menu [nzMode]="'inline'" style="height:100%">
          <li nz-menu-item (click)="Sider ='1'">Java简介</li>
          <li nz-menu-item (click)="Sider ='2'">Java发展历史</li>
          <li nz-menu-item (click)="Sider ='3'">Java对象和类</li>
          <li nz-menu-item (click)="Sider ='4'">Java基本数据类型</li>
          <li nz-menu-item (click)="Sider ='5'">Java变量类型</li>
          <li nz-menu-item (click)="Sider ='6'">Java修饰符</li>
          <li nz-menu-item (click)="Sider ='7'">Java运算符</li>
          <li nz-menu-item (click)="Sider ='8'">Java循环结构</li>
          <li nz-menu-item (click)="Sider ='9'">Java语句结构</li>
        </ul>
      </div>

      <!--相关资源的侧边栏-->
      <div *ngIf=" MODE == 'resource'">
        <button nz-button nzType="primary" (click)="open()">Open</button>
      </div>

    </nz-sider>

    <!--// 主体-->
    <nz-layout >

      <nz-content style="background: #ffffff; padding: 24px; min-height: 650px;">
        <!--主页内容-->
        <div *ngIf="MODE =='main'">
          <!--步骤条-->
          <div style=" padding: 20px 200px 20px 0px">
            <h1>Java 学习之路</h1>
            <nz-steps>
              <nz-step nzTitle="Finished" nzDescription="基础知识"></nz-step>
              <nz-step nzTitle="In Progress" nzDescription="进阶知识"></nz-step>
              <nz-step nzTitle="Waiting" nzDescription="实例教程"></nz-step>
            </nz-steps>
          </div>
          <!--卡片-->
          <div style="background: inherit;">
            <div nz-row [nzGutter]="8">
              <div nz-col [nzSpan]="8">
                <nz-card nzHoverable style="width:240px;height: 400px" [nzCover]="coverTemplate1">
                  <nz-card-meta nzTitle="最全的Java基础知识" nzDescription="了解Java的发展史以及各种技术操作"></nz-card-meta>
                </nz-card>
                <ng-template #coverTemplate1>
                  <img alt="example" src="../../assets/img/java1.png" (click)="MODE='addition'" />
                </ng-template>
              </div>
              <div nz-col [nzSpan]="8">
                <nz-card nzHoverable style="width:240px;height: 400px" [nzCover]="coverTemplate2">
                  <nz-card-meta nzTitle="最前沿的Java技术" nzDescription="助你在Java之路快人一步"></nz-card-meta>
                </nz-card>
                <ng-template #coverTemplate2>
                  <img alt="example" src="../../assets/img/java2.png" (click)="MODE='advanced'" />
                </ng-template>
              </div>
              <div nz-col [nzSpan]="8">
                <nz-card nzHoverable style="width:240px;height: 400px" [nzCover]="coverTemplate3">
                  <nz-card-meta nzTitle="最直观地的用例教学" nzDescription="轻松巩固之前所学"></nz-card-meta>
                </nz-card>
                <ng-template #coverTemplate3>
                  <img alt="example" src="../../assets/img/java3.png" (click)="MODE='fundament'" />
                </ng-template>
              </div>
            </div>
          </div>
          <!--知识点-->
          <div style=" padding: 50px 180px 20px 0px">
            <h1>推荐知识点</h1>
            <div style="background: #ECECEC;padding:30px;">
              <div nz-row [nzGutter]="8" *ngFor="let a of newResource">
                <div nz-col [nzSpan]="8">
                  <nz-card nzTitle="{{a.resourcename}}">
                  </nz-card>
                </div>
              </div>
            </div>
          </div>
          <!--工具-->
          <div style=" padding: 50px 180px 20px 0px">
            <h1>推荐工具</h1>
            <div style="background: #ECECEC;padding:30px;">
              <div nz-row [nzGutter]="8">
                <div nz-col [nzSpan]="8">
                  <nz-card nzTitle="Card title">
                    <p>Card content</p>
                  </nz-card>
                </div>
                <div nz-col [nzSpan]="8">
                  <nz-card nzTitle="Card title">
                    <p>Card content</p>
                  </nz-card>
                </div>
                <div nz-col [nzSpan]="8">
                  <nz-card nzTitle="Card title">
                    <p>Card content</p>
                  </nz-card>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!--知识点模块-->
        <div *ngIf="MODE =='addition'">

          <div *ngIf=" Sider == '1'">

            <h1>Java简介</h1>
            <h3>Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。</h3>

            <h3>由James Gosling和同事们共同研发，并在1995年正式推出。</h3>

            <h3>Java分为三个体系：</h3><br />
            <nz-timeline style="font-size: 30px">
              <nz-timeline-item>JavaSE（J2SE）（Java2 Platform Standard Edition，java平台标准版）</nz-timeline-item>
              <nz-timeline-item>JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版)</nz-timeline-item>
              <nz-timeline-item>JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)。</nz-timeline-item>
            </nz-timeline>
            <h3>2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名以取消其中的数字"2"：J2EE更名为Java EE,</h3>
              <h3>J2SE更名为Java SE，J2ME更名为Java ME。</h3>
          </div>

          <div *ngIf=" Sider == '2'">

            <h1>Java 基本数据类型</h1>
            <p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。</p>
            <p>内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。</p>
            <p>
              <img src="//www.runoob.com/wp-content/uploads/2013/12/memorypic1.jpg"></p>
            <p>因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。</p>
            <p>Java 的两大数据类型:</p>
            <ul><li>内置数据类型</li>
              <li>引用数据类型</li>
            </ul><hr>
            <h2>内置数据类型</h2>
            <p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 </p>
            <p><strong>byte：</strong></p>
            <ul>
              <li>
                byte 数据类型是8位、有符号的，以二进制补码表示的整数；</li>
              <li>
                最小值是 <span class="marked">-128（-2^7）</span>；</li>
              <li>
                最大值是 <span class="marked">127（2^7-1）</span>；</li>
              <li>
                默认值是 <span class="marked">0</span>；</li>
              <li>
                byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；</li>
              <li>
                例子：byte a = 100，byte b = -50。</li>
            </ul><p><strong>short：</strong></p>
            <ul>
              <li>
                short 数据类型是 16 位、有符号的以二进制补码表示的整数</li>
              <li>
                最小值是 <span class="marked">-32768（-2^15）</span>；</li>
              <li>
                最大值是 <span class="marked">32767（2^15 - 1）</span>；</li>
              <li>
                Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；</li>
              <li>
                默认值是 <span class="marked">0</span>；</li>
              <li>
                例子：short s = 1000，short r = -20000。</li>
            </ul>
            <p><strong>int：</strong></p>
            <ul>
              <li>
                int 数据类型是32位、有符号的以二进制补码表示的整数；</li>
              <li>
                最小值是 <span class="marked">-2,147,483,648（-2^31）</span>；</li>
              <li>
                最大值是 <span class="marked">2,147,483,647（2^31 - 1）</span>；</li>
              <li>
                一般地整型变量默认为 int 类型；</li>
              <li>
                默认值是 <span class="marked">0</span> ；</li>
              <li>
                例子：int a = 100000, int b = -200000。</li>
            </ul>
            <p><strong>long：</strong></p>
            <ul>
              <li>
                long 数据类型是 64 位、有符号的以二进制补码表示的整数；</li>
              <li>
                最小值是 <span class="marked">-9,223,372,036,854,775,808（-2^63）</span>；</li>
              <li>
                最大值是 <span class="marked">9,223,372,036,854,775,807（2^63 -1）</span>；</li>
              <li>
                这种类型主要使用在需要比较大整数的系统上；</li>
              <li>
                默认值是 <span class="marked">0L</span>；</li>
              <li>
                例子： long a = 100000L，Long b = -200000L。<br>
                "L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写。
              </li>
            </ul>
            <p><strong>float：</strong></p>
            <ul>
              <li>
                float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li>
              <li>
                float 在储存大型浮点数组的时候可节省内存空间；</li>
              <li>
                默认值是 <span class="marked">0.0f</span>；</li>
              <li>
                浮点数不能用来表示精确的值，如货币；</li>
              <li>
                例子：float f1 = 234.5f。</li>
            </ul>
            <p><strong>double：</strong></p>
            <ul>
              <li>
                double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；</li>
              <li>
                浮点数的默认类型为double类型；</li>
              <li>
                double类型同样不能表示精确的值，如货币；</li>
              <li>
                默认值是 <span class="marked">0.0d</span>；</li>
              <li>
                例子：double d1 = 123.4。</li>
            </ul>
            <p><strong>boolean：</strong></p>
            <ul>
              <li>
                boolean数据类型表示一位的信息；</li>
              <li>
                只有两个取值：true 和 false；</li>
              <li>
                这种类型只作为一种标志来记录 true/false 情况；</li>
              <li>
                默认值是 <span class="marked">false</span>；</li>
              <li>
                例子：boolean one = true。</li>
            </ul>
            <p><strong>char：</strong></p>
            <ul>
              <li>
                char类型是一个单一的 16 位 Unicode 字符；</li>
              <li>
                最小值是 <span class="marked">\u0000</span>（即为0）；</li>
              <li>
                最大值是 <span class="marked">\uffff</span>（即为65,535）；</li>
              <li>
                char 数据类型可以储存任何字符；</li>
              <li>
                例子：char letter = 'A';。</li>
            </ul>
          </div>

          <div *ngIf=" Sider == '3'">

            <h1>Java 变量类型</h1>
            <p>Java语言支持的变量类型有：</p>
            <ul>
              <li>
                类变量：独立于方法之外的变量，用 static 修饰。</li>
              <li>
                实例变量：独立于方法之外的变量，不过没有 static 修饰。  </li>
              <li>
                局部变量：类的方法中的变量。</li>
            </ul>
            <hr>
            <h2>Java 局部变量</h2>
            <ul>
              <li>
                局部变量声明在方法、构造方法或者语句块中；</li>
              <li>
                局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li>
              <li>
                访问修饰符不能用于局部变量；</li>
              <li>
                局部变量只在声明它的方法、构造方法或者语句块中可见；</li>
              <li>
                局部变量是在栈上分配的。</li>
              <li>
                局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li>
            </ul>
            <hr>
            <h2>实例变量</h2>
            <ul>
              <li>
                实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li>
              <li>
                当一个对象被实例化之后，每个实例变量的值就跟着确定；</li>
              <li>
                实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</li>
              <li>
                实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li>
              <li>
                实例变量可以声明在使用前或者使用后；</li>
              <li>
                访问修饰符可以修饰实例变量；</li>
              <li>
                实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li>
              <li>
                实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li>
              <li>
                实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</li>
            </ul>
            <hr>
            <h2>类变量（静态变量）</h2>
            <ul>
              <li>
                类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。</li>
              <li>
                无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li>
              <li>
                静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。</li>
              <li>
                静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。</li>
              <li>
                静态变量在第一次被访问时创建，在程序结束时销毁。</li>
              <li>
                与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。</li>
              <li>
                默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li>
              <li>
                静态变量可以通过：<em>ClassName.VariableName</em>的方式访问。</li>
              <li>
                类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</li>
            </ul>



          </div>

          <div *ngIf=" Sider == '4'">

            <h1>Java 继承</h1>
            <h2>继承的概念</h2><p>
            继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p>
            <p>
              继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。
            </p>
            <h3>生活中的继承：
            </h3>

            <p><img src="//www.runoob.com/wp-content/uploads/2013/12/14B0951E-FC75-47A3-B611-4E1883887339.jpg"></p>
            <p>兔子和羊属于食草动物类，狮子和豹属于食肉动物类。</p><p>
            食草动物和食肉动物又是属于动物类。</p><p>
            所以继承需要符合的关系是：is-a，父类更通用，子类更具体。</p><p>
            虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以子类会具有父类的一般特性也会具有自身的特性。</p>
            <h3>继承类型
            </h3>
            <p>需要注意的是 Java 不支持多继承，但支持多重继承。</p>
            <p><img src="//www.runoob.com/wp-content/uploads/2013/12/types_of_inheritance.png"></p>
            <hr>
            <h2>继承的特性</h2><ul><li><p>
            子类拥有父类非 private 的属性、方法。</p></li><li><p>
            子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</p></li><li><p>
            子类可以用自己的方式实现父类的方法。</p></li><li><p>
            Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</p></li><li><p>
            提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</p></li></ul>
            <hr>
            <h2>继承关键字
            </h2>
            <p>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 <strong>java.lang</strong> 包中，所以不需要 <strong>import</strong>）祖先类。</p>
            <h3>extends关键字</h3>
            <p>在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。</p>

          </div>

          <div *ngIf=" Sider == '5'">
            <h1>Java 多态</h1>
            <hr>

            <p>多态是同一个行为具有多个不同表现形式或形态的能力。</p>
            <p>多态就是同一个接口，使用不同的实例而执行不同操作，如图所示：</p>
            <p><img src="//www.runoob.com/wp-content/uploads/2013/12/dt-java.png"></p>
            <p>多态性是对象多种表现形式的体现。</p>

            <blockquote>
              <p>现实中，比如我们按下 F1 键这个动作：
              </p>
              <ul><li>
                如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；</li><li>如果当前在 Word 下弹出的就是 Word 帮助；</li><li>在 Windows 下弹出的就是 Windows 帮助和支持。</li></ul><p>同一个事件发生在不同的对象上会产生不同的结果。</p>
            </blockquote>
            <h3>
              多态的优点
            </h3><ul><li>
            1. 消除类型之间的耦合关系</li><li>
            2. 可替换性</li><li>
            3. 可扩充性</li><li>
            4. 接口性</li><li>
            5. 灵活性</li><li>
            6. 简化性</li></ul>

            <h3>多态存在的三个必要条件</h3>
            <ul><li>继承</li><li>重写</li><li>父类引用指向子类对象</li></ul><p>
            比如：</p><pre>Parent p = new Child();</pre>
            <p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。</p>
            <p>多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p>
            <h3>重写</h3>
            <p>我们将介绍在 Java 中，当设计类时，被重写的方法的行为怎样影响多态性。</p><p>
            我们已经讨论了方法的重写，也就是子类能够重写父类的方法。</p><p>
            当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。</p><p>
            要想调用父类中被重写的方法，则必须使用关键字 <strong>super</strong>。</p>
            <hr>
            <h2>多态的实现方式</h2>
            <h3>方式一：重写
            </h3>

            <h3>方式二：接口
            </h3>
            <ul><li><p>
              1. 生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。</p></li><li><p>
              2. java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。</p></li></ul>
            <h3>
              方式三：抽象类和抽象方法</h3>
          </div>

          <div *ngIf=" Sider == '6'">

            <h1>Java 封装</h1>
            <hr>

            <p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。
            </p>
            <p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p><p>
            要访问该类的代码和数据，必须通过严格的接口控制。</p><p>
            封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p><p>
            适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p>
            <h3>封装的优点</h3>
            <ul>

              <li><p>
                1. 良好的封装能够减少耦合。</p></li><li><p>
              2. 类内部的结构可以自由修改。</p></li><li><p>
              3. 可以对成员变量进行更精确的控制。</p></li><li><p>
              4. 隐藏信息，实现细节。</p></li>

            </ul>

          </div>

          <div *ngIf="Sider == '7'">
            <p style="margin-left:0pt;">算法一：分治法</p>

            <ul><li>基本概念</li>
            </ul><p><span style="color:#333333;">1.</span><span style="color:#333333;">把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</span></p>

            <p><span style="color:#333333;">2.</span><span style="color:#333333;">分治策略是对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解</span><span style="color:#333333;">。</span></p>

            <ul><li>适用情况</li>
            </ul><p><span style="color:#333333;">1</span><span style="color:#333333;">)该问题的规模缩小到一定的程度就可以容易地解决</span></p>

            <p><span style="color:#333333;">2</span><span style="color:#333333;">)该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</span></p>

            <p><span style="color:#333333;">3</span><span style="color:#333333;">)利用该问题分解出的子问题的解可以合并为该问题的解；</span></p>

            <p><span style="color:#333333;">4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</span></p>

            <ul><li>分治法的复杂性分析</li>
            </ul>
            <p><span style="color:#333333;">一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：</span></p>

            <p><span style="color:#333333;">T（n）= k T(n/m)+f(n)</span></p>

            <p><span style="color:#333333;">通过迭代法求得方程的解：</span></p>

            <p><span style="color:#333333;">递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当                  mi≤n&lt;mi+1时，T(mi)≤T(n)&lt;T(mi+1)。</span></p>

            <ul><li>分治法例题：合并排序和快速排序</li>
            </ul>
       <!--     <pre class="has">
<code>public class 分治_合并排序 {
	/**
	 * 函数说明：在数组被拆分以后进行合并
	 */
	static void Merge(int a[], int left, int middle, int rigth) {
		//定义左端数组大小
		int n1 = middle - left+1;
		int n2 = rigth - middle;

		//初始化数组，分配内存
		int bejin[] = new int[n1];
		int end[] = new int[n2];

		//数组赋值
		for(int i = 0; i &lt; n1; i++)
			bejin[i] = a[left + i];

		for(int i = 0; i &lt; n2; i++)
			end[i] = a[middle+1+i];

		//用key做原数组索引，没调用一次函数重新给原数组付一次值
		int i = 0, j = 0, key;
		for(key = left; key &lt;= rigth; key++){

			if(n1&gt;i&amp;&amp;n2&gt;j&amp;&amp;i &lt; n1 &amp;&amp; bejin[i] &lt;= end[j])
				a[key] = bejin[i++];
			else if(n1&gt;i&amp;&amp;n2&gt;j&amp;&amp;j &lt; n2 &amp;&amp; bejin[i] &gt;= end[j])
				a[key] = end[j++];
			else if(i == n1 &amp;&amp; j &lt; n2)
				a[key] = end[j++];
			else if(j == n2 &amp;&amp; i &lt; n1)
				a[key] = bejin[i++];
		}
	}
	/**
	 * 差分数组区间，不断分支
	 */
	static void MergeSort(int a[],int left,int rigth) {
		int middle=0;
		if(left&lt;rigth) {
			middle =(rigth+left)/2;
			MergeSort(a, left, middle);
			MergeSort(a, middle+1, rigth);
			Merge(a, left, middle, rigth);
		}
	}
	public static void main(String[] args) {
		int a[]= {85,3,52,9,7,1,5,4};
		MergeSort(a, 0,7);
		for(int i=0;i&lt;8;i++) {
			System.out.print(" "+a[i]);
		}

	}
}</code></pre>

            <pre class="has">
<code>public class 分治_快速排序 {
	/**
	 *交换函数，i，j为数组索引
	 */
	static void swap(int A[], int i, int j)
	{
	    int temp = A[i];
	    A[i] = A[j];
	    A[j] = temp;
	}
	/**
	 * 选取一个关键字(key)作为枢轴，一般取整组记录的第一个数/最后一个，这里采用选取序列最后一个数为枢轴。
	 * 设置两个变量left = 0;right = N - 1;
	 * 从left一直向后走，直到找到一个大于key的值，right从后至前，直至找到一个小于key的值，然后交换这两个数。
	 * 重复第三步，一直往后找，直到left和right相遇，这时将key放置left的位置即可。
	 * @return
	 */
	static int PartSort(int[] array,int left,int right)
	{
	    int key = array[right];//定义基准
	    int count=right;//保存rigth值
	    while(left &lt; right)//防止数组越界
	    {
	        while(left &lt; right &amp;&amp; array[left] &lt;= key)
	        {
	            ++left;
	        }
	        while(left &lt; right &amp;&amp; array[right] &gt;= key)
	        {
	            --right;
	        }
	        swap(array,left,right);
	    }
	    swap(array,right,count);
	    return right;
	}
	/**
	 *分治思想，递归调用
	 */
	static void QuickSort(int array[],int left,int right)
	{
	    if(left &gt;= right)//表示已经完成一个组
	    {
	        return;
	    }
	    int index = PartSort(array,left,right);//枢轴的位置
	    QuickSort(array,left,index - 1);
	    QuickSort(array,index + 1,right);
	}
	public static void main(String[] args) {
		int a[]= {1,5,-5,54,15,67,16,23};
		QuickSort(a,0,7);
		for(int i=0;i&lt;a.length;i++) {
			System.out.print(" "+a[i]);
		}
	    System.out.print("\n");
	}
}</code></pre> -->

          </div>
          <div *ngIf="Sider == '8'">
            <blockquote>
              <p style="margin-left:0pt;">算法二：<span style="color:#333333;">贪心算法</span></p>
            </blockquote>

            <p style="margin-left:0pt;">一、基本概念：</p>

            <p><span style="color:#333333;">所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。</span></p>

            <p><span style="color:#333333;">贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</span></p>

            <p><span style="color:#333333;">所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</span></p>

            <p style="margin-left:0pt;">二、贪心算法的基本思路：</p>

            <p><span style="color:#333333;">1.建立数学模型来描述问题。</span></p>

            <p><span style="color:#333333;">2.把求解的问题分成若干个子问题。</span></p>

            <p><span style="color:#333333;">3.对每一子问题求解，得到子问题的局部最优解。</span></p>

            <p><span style="color:#333333;">4.把子问题的解局部最优解合成原来解问题的一个解</span><span style="color:#333333;">。</span></p>

            <p style="margin-left:0pt;">三、贪心算法适用的问题</p>

            <p><span style="color:#333333;">贪心策略适用的前提是：局部最优策略能导致产生全局最优解。</span></p>

            <p><span style="color:#333333;">实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</span></p>

            <p style="margin-left:0pt;">四、贪心算法的实现框架</p>

            <p><span style="color:#333333;">从问题的某一初始解出发；</span></p>

            <p><span style="color:#333333;">while （能朝给定总目标前进一步）</span></p>

            <p><span style="color:#333333;">利用可行的决策，求出可行解的一个解元素；</span></p>

            <p><span style="color:#333333;">由所有解元素组合成问题的一个可行解；  </span></p>

            <p style="margin-left:0pt;">五、贪心策略的选择</p>

            <p><span style="color:#333333;">因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。</span></p>

            <ul><li>贪心策略例题：prim算法</li>
            </ul>
            <!--      <pre class="has">
      <code>import java.util.*;
      public class 贪心算法_prim算法 {
          static int MAX = Integer.MAX_VALUE;
          public static void main(String[] args) {
              //定义无向图矩阵
              int[][] map = new int[][] {
                      { 0, 1, 6, 2},
                      { 1, 0, 3, 2},
                      { 6, 3, 0, 1},
                      { 2, 2, 1, 0}
                      };
              prim(map, map.length);
          }
          public static void prim(int[][] graph, int n){
                  //定义节点名字
                  char[] c = new char[]{'A','B','C','D'};
                  int[] lowcost = new int[n];  //到新集合的最小权
                  int[] mid= new int[n];//存取前驱结点
                  List&lt;Character&gt; list=new ArrayList&lt;Character&gt;();//用来存储加入结点的顺序
                  int i, j, min, minid , sum = 0;
                  //初始化辅助数组
                  for(i=1;i&lt;n;i++)
                  {
                      lowcost[i]=graph[0][i];
                      mid[i]=0;
                  }
                  list.add(c[0]);
                  //一共需要加入n-1个点
                  for(i=1;i&lt;n;i++)
                  {
                       min=MAX;
                       minid=0;
                       //每次找到距离集合最近的点
                       for(j=1;j&lt;n;j++)
                       {
                           if(lowcost[j]!=0&amp;&amp;lowcost[j]&lt;min)
                           {
                               min=lowcost[j];
                               minid=j;
                           }
                       }
                       if(minid==0) return;
                       list.add(c[minid]);
                       lowcost[minid]=0;
                       sum+=min;
                       System.out.println(c[mid[minid]] + "到" + c[minid] + " 权值：" + min);
                       //加入该点后，更新其它点到集合的距离
                       for(j=1;j&lt;n;j++)
                       {
                           if(lowcost[j]!=0&amp;&amp;lowcost[j]&gt;graph[minid][j])
                           {
                               lowcost[j]=graph[minid][j];
                               mid[j]=minid;
                           }
                       }
                       System.out.print("\n");
                  }
                  System.out.println("sum:" + sum);
              }
      }
      </code></pre>-->

          </div>

          <div *ngIf="Sider == '9'">
            <blockquote>
              <p style="margin-left:0pt;">算法三：动态规划算法</p>
            </blockquote>

            <p style="margin-left:0pt;">一、基本概念</p>

            <p>    <span style="color:#333333;">动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。</span></p>

            <p style="margin-left:0pt;">二、基本思想与策略</p>

            <p>    <span style="color:#333333;">基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</span></p>

            <p><span style="color:#333333;">    由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</span></p>

            <p><span style="color:#333333;">    与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</span></p>

            <p style="margin-left:0pt;">三、适用的情况</p>

            <p><span style="color:#333333;">能采用动态规划求解的问题的一般要具有3个性质：</span></p>

            <p><span style="color:#333333;">    (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</span></p>

            <p><span style="color:#333333;">    (2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</span></p>

            <p><span style="color:#333333;">   （3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</span></p>

            <p style="margin-left:0pt;">三、算法实例：背包问题</p>

            <!--       <pre class="has">
       <code>public class 动态规划_背包问题 {
       public static void main(String[] args) {
           //物品价值,重量,和背包承重
           int v[]={0,8,10,6,3,7,2};
           int w[]={0,4,6,2,2,5,1};
           int c=12;

           //定义二位数组动态规划背包价值和重量
           int m[][]=new int[v.length][c+1];
           for (int i = 1; i &lt;v.length; i++) {
               for (int j = 1; j &lt;=c; j++) {
                   if(j&gt;=w[i])
                       m[i][j]=m[i-1][j-w[i]]+v[i]&gt;m[i-1][j]?m[i-1][j-w[i]]+v[i]:m[i-1][j];
                   else
                       m[i][j]=m[i-1][j];
               }
           }
           int max=0;
           for (int i = 0; i &lt;v.length; i++) {
               for (int j = 0; j &lt;=c; j++) {
                   if(m[i][j]&gt;max)
                       max=m[i][j];
               }
           }
           System.out.println(max);
       }
       }</code></pre>-->


          </div>

          <div *ngIf="Sider == '10'">
            <blockquote>
              <p style="margin-left:0pt;">算法四：回溯法</p>
            </blockquote>

            <p style="margin-left:0pt;">1、概念</p>

            <p style="margin-left:0pt;">回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>

            <p style="margin-left:0pt;">回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>

            <p style="margin-left:0pt;">许多<span style="color:#333333;">复杂的，规模较大</span>的问题都可以使用回溯法，有“通用解题方法”的美称。</p>

            <p style="margin-left:0pt;">2、基本思想</p>

            <p style="margin-left:0pt;">在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。</p>

            <p style="margin-left:0pt;">若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。</p>

            <p style="margin-left:0pt;">而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p>

            <p style="margin-left:0pt;">3、用回溯法解题的一般步骤：</p>

            <p style="margin-left:0pt;"><span style="color:#333333;">（</span>1）针对所给问题，确定问题的解空间：</p>

            <p style="margin-left:0pt;">首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。</p>

            <p style="margin-left:0pt;">（2）确定结点的扩展搜索规则</p>

            <p style="margin-left:0pt;">（3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</p>

            <p style="margin-left:0pt;">4、算法实例：求子集问题</p>

            <!--  <pre class="has">
  <code>public class 回溯法_求子集问题 {
          private static int[] s = {2,2,3};
          private static int n = s.length;
          private static int[] x = new int[n];
          /**
           * 输出集合的子集
           * @param limit  决定选出特定条件的子集
           * 注：all为所有子集,num为限定元素数量的子集,
           *    sp为限定元素奇偶性相同，且和小于8。
           */
          public static void all_subset(String limit){
              switch(limit){
              case "all":backtrack(0);break;
              case "num":backtrack1(0);break;
              case "sp":backtrack2(0);break;
              }
          }
          /**
           * 回溯法求集合的所有子集，依次递归
           * 注：是否回溯的条件为精髓
           * @param t
           */
          private static void backtrack(int t){
              if(t &gt;= n)
                  output(x);
              else
                  for (int i = 0; i &lt;= 1; i++) {
                      x[t] = i;
                      backtrack(t+1);
                  }
          }
          /**
           * 回溯法求集合的所有(元素个数小于4)的子集，依次递归
           * @param t
           */
          private static void backtrack1(int t){
              if(t &gt;= n)
                  output(x);
              else
                  for (int i = 0; i &lt;= 1; i++) {
                      x[t] = i;
                      if(count(x, t) &lt; 4)
                          backtrack1(t+1);
                  }
          }

          /**
           * (剪枝)
           * 限制条件：子集元素小于4,判断0~t之间已被选中的元素个数，
           *        因为此时t之后的元素还未被递归,即决定之后的元素
           *        是否应该被递归调用
           * @param x
           * @param t
           * @return
           */
          private static int count(int[] x, int t) {
              int num = 0;
              for (int i = 0; i &lt;= t; i++) {
                  if(x[i] == 1){
                      num++;
                  }
              }
              return num;
          }
          /**
           * 回溯法求集合中元素奇偶性相同，且和小于8的子集,依次递归
           * @param t
           */
          private static void backtrack2(int t){
              if(t &gt;= n)
                  output(x);
              else
                  for (int i = 0; i &lt;= 1; i++) {
                      x[t] = i;
                      if(legal(x, t))
                          backtrack2(t+1);
                  }
          }
          /**
           * 对子集中元素奇偶性进行判断，还需元素的数组和小于8
           * @param x
           * @param t
           * @return
           */
          private static boolean legal(int[] x, int t) {
              boolean bRet = true;   //判断是否需要剪枝
              int part = 0;  //奇偶性判断的基准

              for (int i = 0; i &lt;= t; i++) {  //选择第一个元素作为奇偶性判断的基准
                  if(x[i] == 1){
                      part = i;
                      break;
                  }
              }
              for (int i = 0; i &lt;= t; i++) {
                  if(x[i] == 1){
                      bRet &amp;= ((s[part] - s[i]) % 2 == 0);
                  }
              }
              int sum = 0;
              for(int i = 0; i &lt;= t; i++){
                  if(x[i] == 1)
                      sum += s[i];
              }
              bRet &amp;= (sum &lt; 8);
              return bRet;
          }
          /**
           * 子集输出函数
           * @param x
           */
          private static void output(int[] x) {
              for (int i = 0; i &lt; x.length; i++) {
                  if(x[i] == 1){
                      System.out.print(s[i]);
                  }
              }
              System.out.println();
          }
        public static void main(String[] args) {
            all_subset("all");
      }
  } </code></pre> -->
          </div>

          <div *ngIf="Sider == '11'">
            <blockquote>
              <p style="margin-left:0pt;"><span style="color:#333333;">算法五：分支限界法</span></p>
            </blockquote>

            <p>一、基本描述</p>

            <p>    类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。<strong>回溯法的求解目标是找出T中满足约束条件的所有解</strong>，而<strong>分支限界法</strong>的求解目标则是找出<strong>满足约束条件的一个解</strong>，或是在满足约束条件的解中找出使某一目标函数值达到<strong>极大或极小的解</strong>，即在某种意义下的<strong>最优解</strong>。</p>

            <p>   （1）分支搜索算法</p>

            <p>    所谓“分支”就是采用广度优先的策略，依次搜索E-结点的所有分支，也就是所有相邻结点，抛弃不满足约束条件的结点，其余结点加入活结点表。然后从表中选择一个结点作为下一个E-结点，继续搜索。</p>

            <p>     选择下一个E-结点的方式不同，则会有几种不同的分支搜索方式。</p>

            <p>   1）FIFO搜索</p>

            <p>   2）LIFO搜索</p>

            <p>   3）优先队列式搜索</p>

            <p>（2）分支限界搜索算法 </p>

            <p>二、分支限界法的一般过程</p>

            <p>    由于求解目标不同，导致分支限界法与回溯法在解空间树T上的搜索方式也不相同。<strong>回溯法以深度优先的方式搜索解空间树T</strong>，而<strong>分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T</strong>。</p>

            <p>    分支限界法的<strong>搜索策略是</strong>：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。</p>

            <p>    分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。问题的<strong>解空间树是表示问题解空间的一棵有序树，常见的有子集树和排列树</strong>。在搜索问题的解空间树时，分支限界法与回溯法对当前扩展结点所使用的扩展方式不同。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，那些导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被子加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所求的解或活结点表为空时为止。</p>

            <p>三、回溯法和分支限界法的一些区别</p>

            <p>    有一些问题其实无论用回溯法还是分支限界法都可以得到很好的解决，但是另外一些则不然。也许我们需要具体一些的分析——到底何时使用分支限界而何时使用回溯呢？</p>

            <p>回溯法和分支限界法的一些区别：</p>

            <p>   方法对解空间树的搜索方式 <a href="http://www.storworld.com/" rel="nofollow">存储</a>结点的常用数据结构结点<a href="http://www.storworld.com/" rel="nofollow">存储</a>特性常用应用</p>

            <p>  回溯法深度优先搜索堆栈活结点的所有可行子结点被遍历后才被从栈中弹出找出满足约束条件的所有解</p>

            <p>  分支限界法广度优先或最小消耗优先搜索队列、优先队列每个结点只有一次成为活结点的机会找出满足约束条件的一个解或特定意义下的最优解</p>

            <!--        <pre class="has">
        <code>import java.util.Collections;

        import java.util.LinkedList;

        public class 分支界限法_求最大承重问题 {
            LinkedList&lt;HeapNode&gt; heap;
            public static class BBnode{
                BBnode parent;//父结点
                boolean leftChild;//左儿子结点标志
                //构造方法
                public BBnode(BBnode par,boolean ch){
                    parent=par;
                    leftChild=ch;
                }
            }
            /**
             * 输出函数，做调试用
             * @param list
             */
            public static void printReverse(LinkedList&lt;HeapNode&gt; list){
                for (int i=0;i&lt;list.size();i++) {
                    HeapNode aBnode=list.get(i);
                    System.out.print("#"+aBnode.uweight+"#"+aBnode.level+" ");
                }

                }
            /*
             * 最大优先队列中存储的活结点类型为HeapNode
             */
            public static class HeapNode implements Comparable{
                BBnode liveNode;
                int uweight;//活结点优先级（上界）
                int level;//活结点在子集树种所处的层序号
                //构造函数
                public HeapNode(BBnode node,int up,int lev){
                    liveNode=node;
                    uweight=up;
                    level=lev;
                }
                @Override
                public int compareTo(Object x) {//升序排列
                    int xu=((HeapNode)x).uweight;
                    if(uweight&lt;xu) return -1;
                    if(uweight==xu) return 0;
                    return 1;
                }
                public boolean equals(Object x){
                    return uweight==((HeapNode)x).uweight;
                }
            }
            public void addLiveNode(int up,int lev,BBnode par,boolean ch){
                //将活结点加入到表示活结点优先队列的最大堆H中
                BBnode b=new BBnode(par,ch);
                HeapNode node=new HeapNode(b,up,lev);
                heap.add(node);
                Collections.sort(heap);
            }
            public int maxLoading(int[] w,int c,int[] bestx){
                int count=0;
                //优先队列式分支限界法，返回最优重量，bestx返回最优解
                heap=new LinkedList&lt;HeapNode&gt;();
                int n=w.length-1;
                BBnode e=null;//当前扩展结点
                int i=1;//当前扩展结点所处的层
                int ew=0;//扩展结点所对应的载重量
                //定义剩余重量数组r
                int[] r=new int[n+1];
                for(int j=n-1;j&gt;0;j--) {
                    r[j]=r[j+1]+w[j+1];
                }
                //搜索子集空间树
                while(i!=n+1){
                    //非叶结点
                    //检查当前扩展结点的儿子结点
                    if(ew+w[i]&lt;=c){
                        //左儿子结点为可行结点
                        addLiveNode(ew+w[i]+r[i],i+1,e,true);
                    }
                    //右儿子结点总为可行结点
                    addLiveNode(ew+r[i],i+1,e,false);
                    //printReverse(heap);
                    //取下一个结点
                    HeapNode node=heap.pollLast();
                    i=node.level;
                    e=node.liveNode;
                    ew=node.uweight-r[i-1];
                }

                //输出
                for(int j=0;j&lt;n;j++){
                    bestx[j]=(e.leftChild)?1:0;
                    e=e.parent;
                }
                for(int j=n-1;j&gt;=0;j--){
                    System.out.print(bestx[j]+" ");
                }
                System.out.println();
                return ew;
            }
            public static void main(String[] args) {
                int n=4;
                int c=70;
                int w[]={0,26,60,22,18};//下标从1开始
                int[] bestx=new int[n+1];
                分支界限法_求最大承重问题 b=new 分支界限法_求最大承重问题();
                System.out.println("最优装载顺序为（1表示装入，0表示未装入）：");
                int ew=b.maxLoading(w, c, bestx);
                System.out.println("最优装载重量为："+ew);
            }
        }</code></pre> -->

          </div>

        </div>

        <!--拓展知识模块-->
        <div *ngIf=" MODE == 'advanced'">
          <!--预览模式-->
          <div *ngIf=" TYPE == 'finish'">
            <i nz-icon type="edit" theme="outline" (click)=" TYPE = 'edit'"></i>
            <nz-tabset>
              <nz-tab nzTitle="{{title}}">
                <pre [innerHTML]="preview" ></pre>
              </nz-tab>
            </nz-tabset>
          </div>
          <!--编辑模式-->
          <div *ngIf=" TYPE == 'edit'">
            <i nz-icon type="save" theme="twotone" (click)="TYPE = 'finish'"></i>
            <nz-tabset>
              <nz-tab nzTitle="Write">
                <nz-mention [nzSuggestions]="suggestions">
          <textarea
            nz-input
            [nzAutosize]="{ minRows: 20, maxRows: 20}"
            [(ngModel)]="inputValue"
            (ngModelChange)="renderPreView()"
            nzMentionTrigger
          >
          </textarea>
                </nz-mention>
              </nz-tab>
              <nz-tab nzTitle="Preview">
                <pre [innerHTML]="preview"></pre>
              </nz-tab>
            </nz-tabset>
          </div>

        </div>

        <!--集合框架-->
        <div *ngIf="MODE == 'fundament'">
          <!--简述Spring 框架-->
          <div *ngIf=" Sider == '1'">
            <h1>简述Spring 框架</h1>
            <p>Spring 框架是 Java 应用最广的框架，它的<strong>成功来源于理念，而不是技术本身</strong>，它的理念包括 <strong>IoC (Inversion of Control，控制反转)</strong> 和 <strong>AOP(Aspect Oriented Programming，面向切面编程)</strong>。</p>
            <h4 id="什么是-spring">什么是 Spring：</h4>
            <ol>
              <li>Spring 是一个<strong>轻量级的 DI / IoC 和 AOP 容器的开源框架</strong>，来源于 Rod Johnson 在其著作<strong>《Expert one on one J2EE design and development》</strong>中阐述的部分理念和原型衍生而来。</li>
              <li>Spring 提倡以<strong>“最少侵入”</strong>的方式来管理应用中的代码，这意味着我们可以随时安装或者卸载 Spring</li>
            </ol>
            <ul>
              <li><strong>适用范围：任何 Java 应用</strong></li>
              <li><strong>Spring 的根本使命：简化 Java 开发</strong></li>
            </ul>
            <blockquote>
              <p>尽管 J2EE 能够赶上 Spring 的步伐，<strong>但 Spring 并没有停止前进，</strong> Spring 继续在其他领域发展，而 J2EE 则刚刚开始涉及这些领域，或者还没有完全开始在这些领域的创新。<strong>移动开发、社交 API 集成、NoSQL 数据库、云计算以及大数据</strong>都是 Spring 正在涉足和创新的领域。Spring 的前景依然会很美好。</p>
            </blockquote>
            <video src="../../assets/Spring.mp4" width="500px" height="300px" controls="controls" type="video/mp4"></video>
            <h4 id="spring-中常用术语">Spring 中常用术语：</h4>
            <ul>
              <li><strong>框架：</strong>是能<strong>完成一定功能</strong>的<strong>半成品</strong>。<br />
                框架能够帮助我们完成的是：<strong>项目的整体框架、一些基础功能、规定了类和对象如何创建，如何协作等</strong>，当我们开发一个项目时，框架帮助我们完成了一部分功能，我们自己再完成一部分，那这个项目就完成了。</li>
              <li><strong>非侵入式设计：</strong><br />
                从框架的角度可以理解为：<strong>无需继承框架提供的任何类</strong><br />
                这样我们在更换框架时，之前写过的代码几乎可以继续使用。</li>
              <li><strong>轻量级和重量级：</strong><br />
                轻量级是相对于重量级而言的，<strong>轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等</strong>，其实就是<strong>比较容易使用</strong>，而<strong>重量级正好相反</strong>。</li>
              <li><strong>JavaBean：</strong><br />
                即<strong>符合 JavaBean 规范</strong>的 Java 类</li>
              <li><strong>POJO：</strong>即 <strong>Plain Old Java Objects，简单老式 Java 对象</strong><br />
                它可以包含业务逻辑或持久化逻辑，但<strong>不担当任何特殊角色</strong>且<strong>不继承或不实现任何其它Java框架的类或接口。</strong></li>
            </ul>
            <p><em>注意：bean 的各种名称——虽然 Spring 用 bean 或者 JavaBean 来表示应用组件，但并不意味着 Spring 组件必须遵循 JavaBean 规范，一个 Spring 组件可以是任意形式的 POJO。</em></p>
            <ul>
              <li><strong>容器：</strong><br />
                在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是<strong>装对象的的对象</strong>，因为存在<strong>放入、拿出等</strong>操作，所以容器还要<strong>管理对象的生命周期</strong>。</li>
            </ul>
          </div>

          <div *ngIf="Sider == '2'">
            <h4 id="spring-的优势">Spring 的优势</h4>
            <ul>
              <li><strong>低侵入 / 低耦合</strong> （降低组件之间的耦合度，实现软件各层之间的解耦）</li>
              <li><strong>声明式事务管理</strong>（基于切面和惯例）</li>
              <li><strong>方便集成其他框架</strong>（如MyBatis、Hibernate）</li>
              <li><strong>降低 Java 开发难度</strong></li>
              <li>Spring 框架中包括了 J2EE 三层的每一层的解决方案（一站式）</li>
            </ul>
            <h4 id="spring-能帮我们做什么">Spring 能帮我们做什么</h4>
            <p><strong>①.Spring</strong> 能帮我们根据配置文件<strong>创建及组装对象之间的依赖关系</strong>。<br />
              <strong>②.Spring 面向切面编程</strong>能帮助我们<strong>无耦合的实现日志记录，性能统计，安全控制。</strong><br />
              <strong>③.Spring</strong> 能<strong>非常简单的帮我们管理数据库事务</strong>。<br />
              <strong>④.Spring</strong> 还<strong>提供了与第三方数据访问框架（如Hibernate、JPA）无缝集成</strong>，而且自己也提供了一套<strong>JDBC访问模板</strong>来方便数据库访问。<br />
              <strong>⑤.Spring</strong> 还提供与<strong>第三方Web（如Struts1/2、JSF）框架无缝集成</strong>，而且自己也提供了一套<strong>Spring MVC</strong>框架，来方便web层搭建。<br />
              <strong>⑥.Spring</strong> 能<strong>方便的与Java EE（如Java Mail、任务调度）整合</strong>，与<strong>更多技术整合（比如缓存框架）</strong>。</p>
            <video src="../../assets/Spring优势.mp4" width="500px" height="300px" controls="controls" type="video/mp4"></video>
            <h4 id="spring-的框架结构">Spring 的框架结构</h4>
            <p><img src="https://upload-images.jianshu.io/upload_images/7896890-a7c003d175bd41af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
            <ul>
              <li><strong>Data Access/Integration层</strong>包含有JDBC、ORM、OXM、JMS和Transaction模块。</li>
              <li><strong>Web层</strong>包含了Web、Web-Servlet、WebSocket、Web-Porlet模块。</li>
              <li><strong>AOP模块</strong>提供了一个符合AOP联盟标准的面向切面编程的实现。</li>
              <li><strong>Core Container(核心容器)：</strong>包含有Beans、Core、Context和SpEL模块。</li>
              <li><strong>Test模块</strong>支持使用JUnit和TestNG对Spring组件进行测试。</li>
            </ul>
          </div>

          <div *ngIf="Sider == '3'">
            <!--<nz-content style="background: #ffffff; padding: 24px; min-height: 650px; width: inherit;">-->
            <h1>Spring IoC 和 DI 简介</h1>
            <h2 id="spring-ioc-和-di-简介">Spring IoC 和 DI 简介</h2>
            <h4 id="iocinverse-of-control控制反转">IoC：Inverse of Control（控制反转）</h4>
            <ul>
              <li>读作<strong>“反转控制”</strong>，更好理解，不是什么技术，而是一种<strong>设计思想</strong>，就是<strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong></li>
              <li><strong>正控：</strong>若要使用某个对象，需要<strong>自己去负责对象的创建</strong></li>
              <li><strong>反控：</strong>若要使用某个对象，只需要<strong>从 Spring 容器中获取需要使用的对象，不关心对象的创建过程</strong>，也就是把<strong>创建对象的控制权反转给了Spring框架</strong></li>
              <li><strong>好莱坞法则：</strong>Don’t call me ,I’ll call you</li>
            </ul>
            <h4 id="一个例子">一个例子</h4>
            <p>控制反转显然是一个抽象的概念，我们举一个鲜明的例子来说明。</p>
            <p>在现实生活中，人们要用到一样东西的时候，第一反应就是去找到这件东西，比如想喝新鲜橙汁，在没有饮品店的日子里，最直观的做法就是：买果汁机、买橙子，然后准备开水。值得注意的是：这些都是你自己<strong>“主动”创造</strong>的过程，也就是说一杯橙汁需要你自己创造。</p>
            <p><img src="https://upload-images.jianshu.io/upload_images/7896890-e460070aba0d8ab0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
            <p>然而到了今时今日，由于饮品店的盛行，当我们想喝橙汁时，第一想法就转换成了找到饮品店的联系方式，通过电话等渠道描述你的需要、地址、联系方式等，下订单等待，过一会儿就会有人送来橙汁了。</p>
            <p><img src="https://upload-images.jianshu.io/upload_images/7896890-5cebd72ddc461d18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
            <p><strong>请注意你并没有“主动”去创造橙汁</strong>，橙汁是由饮品店创造的，而不是你，然而也完全达到了你的要求，甚至比你创造的要好上那么一些。</p>
            <video src="../../assets/IOC和DI.mp4" width="500px" height="300px" controls="controls" type="video/mp4"></video>
            <h4 id="编写第一个-spring-程序">编写第一个 Spring 程序</h4>
            <ol>
              <li>新建一个空的 Java 项目，命名为【spring】</li>
              <li>新建一个名为【lib】的目录，并添加进必要的 jar 包，导入项目</li>
            </ol>
            <p><img src="https://upload-images.jianshu.io/upload_images/7896890-dada8347bc57dc1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="仅仅为一部分，下方还有一些包" /></p>
            <ol>
              <li>在 Packge【pojo】下新建一个【Source】类：</li>
            </ol>
            <ol>
              <li>在 【src】 目录下新建一个 【applicationContext.xml】 文件，通过 xml 文件配置的方式装配我们的 bean</li>
            </ol>

            <ol>
              <li>在 Packge【test】下新建一个【TestSpring】类：</li>
            </ol>

            <ol>
              <li>运行测试代码，可以正常拿到 xml 配置的 bean</li>
            </ol>
            <p><img src="https://upload-images.jianshu.io/upload_images/7896890-f9923130c12739cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
            <ul>
              <li><strong>总结：</strong></li>
              <li><strong>传统的方式：</strong><br />
                通过new 关键字主动创建一个对象</li>
              <li><strong>IOC方式：</strong><br />
                对象的生命周期由Spring来管理，直接从Spring那里去获取一个对象。 IOC是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，交给了Spring。<br />
                <img src="https://upload-images.jianshu.io/upload_images/7896890-bb752724e10e0df2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="获取对象方式的转变" /></li>
            </ul>
            <blockquote>
              <p>参考地址：<a href="http://how2j.cn/k/spring/spring-ioc-di/87.html#nowhere">这里</a></p>
            </blockquote>
            <h4 id="didependency-injection依赖注入">DI：Dependency Injection（依赖注入）</h4>
            <ul>
              <li>指 Spring 创建对象的过程中，<strong>将对象依赖属性（简单值，集合，对象）通过配置设值给该对象</strong></li>
            </ul>
            <h4 id="继续上面的例子">继续上面的例子</h4>
            <ol>
              <li>在 Packge【pojo】下新建一个【JuiceMaker】类：</li>
            </ol>
            <ol>
              <li>在 xml 文件中配置 JuiceMaker 对象：</li>
            </ol>
            <ul>
              <li><strong>注意：</strong>这里要使用 ref 来<strong>注入</strong>另一个对象</li>
            </ul>

            <ol>
              <li>在 【TestSpring】 中添加如下代码：</li>
            </ol>
            <ol>
              <li>运行测试代码：</li>
            </ol>
            <p><img src="https://upload-images.jianshu.io/upload_images/7896890-ce9088fbfe46301b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
            <p><strong>总结：</strong>IoC 和 DI 其实是同一个概念的不同角度描述，DI 相对 IoC 而言，<strong>明确描述了“被注入对象依赖 IoC 容器配置依赖对象”</strong></p>
            <h4 id="ioc-如何实现的">IoC 如何实现的</h4>
            <p>最后我们简单说说IoC是如何实现的。想象一下如果我们自己来实现这个依赖注入的功能，我们怎么来做？ 无外乎：</p>
            <ol>
              <li>读取标注或者配置文件，看看JuiceMaker依赖的是哪个Source，拿到类名</li>
              <li>使用反射的API，基于类名实例化对应的对象实例</li>
              <li>将对象实例，通过构造函数或者 setter，传递给 JuiceMaker</li>
            </ol>
            <p>我们发现其实自己来实现也不是很难，Spring实际也就是这么做的。这么看的话其实IoC就是一个工厂模式的升级版！当然要做一个成熟的IoC框架，还是非常多细致的工作要做，Spring不仅提供了一个已经成为业界标准的Java IoC框架，还提供了更多强大的功能，所以大家就别去造轮子啦！希望了解IoC更多实现细节不妨通过学习Spring的源码来加深理解！</p>
          </div>

          <div *ngIf="Sider == '4'">
            <h1>Spring AOP 简介</h1>
            <p>如果说 IoC 是 Spring 的核心，那么面向切面编程就是 Spring 最为重要的功能之一了，在数据库事务中切面编程被广泛使用。</p>
            <h4 id="aop-即-aspect-oriented-program-面向切面编程">AOP 即 Aspect Oriented Program 面向切面编程</h4>
            <p>首先，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。</p>
            <ul>
              <li><strong>所谓的核心业务</strong>，比如登陆，增加数据，删除数据都叫核心业务</li>
              <li><strong>所谓的周边功能</strong>，比如性能统计，日志，事务管理等等</li>
            </ul>
            <p>周边功能在 Spring 的面向切面编程AOP思想里，即被定义为切面</p>
            <p>在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 &quot;编织&quot; 在一起，这就叫AOP</p>
            <h4 id="aop-的目的">AOP 的目的</h4>
            <p>AOP能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
            <h4 id="aop-当中的概念">AOP 当中的概念：</h4>
            <ul>
              <li>切入点（Pointcut）<br />
                在哪些类，哪些方法上切入（<strong>where</strong>）</li>
              <li>通知（Advice）<br />
                在方法执行的什么实际（<strong>when:</strong>方法前/方法后/方法前后）做什么（<strong>what:</strong>增强的功能）</li>
              <li>切面（Aspect）<br />
                切面 = 切入点 + 通知，通俗点就是：<strong>在什么时机，什么地方，做什么增强！</strong></li>
              <li>织入（Weaving）<br />
                把切面加入到对象，并创建出代理对象的过程。（由 Spring 来完成）</li>
            </ul>
            <video src="../../assets/AOP.mp4" height="300" width="500" controls="controls" type="video/mp4">您的浏览器不支持播放该视频！</video>
            <h4 id="aop-编程">AOP 编程</h4>
            <ol>
              <li>在 Packge【service】下创建 【ProductService】类：</li>
            </ol>
            <ol>
              <li>在 xml 文件中装配该 bean：</li>
            </ol>
            <pre><code>&lt;bean name=&quot;productService&quot; class=&quot;service.ProductService&quot; /&gt;</code></pre>
            <ol>
              <li>在【TestSpring】中编写测试代码，运行：</li>
            </ol>
            <p><img src="https://upload-images.jianshu.io/upload_images/7896890-c190e07d3a051a65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
            <ol>
              <li>在 Packge【aspect】下准备日志切面 【LoggerAspect】类：</li>
            </ol>

            <ol>
              <li>在 xml 文件中声明业务对象和日志切面：</li>
            </ol>

            <ol>
              <li>再次运行 TestSpring 中的测试代码，代码并没有改变，但是在业务方法运行之前和运行之后，都分别输出了日志信息：</li>
            </ol>
            <p><img src="https://upload-images.jianshu.io/upload_images/7896890-343746f0a4eb7ce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
          </div>

          <div *ngIf="Sider == '5'">
            <h2 id="spring-boot-概述">Spring Boot 概述</h2>
            <blockquote>
              <p><strong>Build Anything with Spring Boot：</strong>Spring Boot is the starting point for building all Spring-based applications. Spring Boot is designed to get you up and running as quickly as possible, with minimal upfront configuration of Spring.</p>
            </blockquote>
            <p>上面是引自官网的一段话，大概是说： Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。</p>
            <h4 id="什么是-spring-boot">什么是 Spring Boot</h4>
            <ul>
              <li>它使用 “习惯优于配置” （项目中存在大量的配置，此外还内置一个习惯性的配置，让你无须）的理念让你的项目快速运行起来。</li>
              <li>它并不是什么新的框架，而是默认配置了很多框架的使用方式，就像 Maven 整合了所有的 jar 包一样，Spring Boot 整合了所有框架（引自：<a href="http://www.ityouknow.com/springboot/2016/01/06/springboot(%E4%B8%80)-%E5%85%A5%E9%97%A8%E7%AF%87.html">springboot(一)：入门篇——纯洁的微笑</a>）</li>
            </ul>

            <h4 id="使用-spring-boot-有什么好处">使用 Spring Boot 有什么好处</h4>
            <p>回顾我们之前的 SSM 项目，搭建过程还是比较繁琐的，需要：</p>
            <ul>
              <li>1）配置 web.xml，加载 spring 和 spring mvc</li>
              <li>2）配置数据库连接、配置日志文件</li>
              <li>3）配置家在配置文件的读取，开启注解</li>
              <li>4）配置mapper文件</li>
              <li><strong>.....</strong></li>
            </ul>
            <p>而使用 Spring Boot 来开发项目则只需要非常少的几个配置就可以搭建起来一个 Web 项目，并且利用 IDEA 可以自动生成生成，这简直是太爽了...</p>
            <ul>
              <li>划重点：简单、快速、方便地搭建项目；对主流开发框架的无配置集成；极大提高了开发、部署效率。</li>
            </ul>
          </div>

          <div *ngIf="Sider == '6'">
            <video src="../../assets/事务.mp4" height="300" width="500" controls="controls" type="video/mp4">您的浏览器不支持播放该视频！</video>
          </div>

          <div *ngIf="Sider == '7'">
            <video src="../../assets/Spring集成Struts2.mp4" height="300" width="500" controls="controls" type="video/mp4">您的浏览器不支持播放该视频！</video>
          </div>

          <div *ngIf="Sider == '8'">
          <video src="../../assets/Spring整合Hibernate.mp4" height="300" width="500" controls="controls" type="video/mp4">您的浏览器不支持播放该视频！</video>
        </div>
        </div>

        <!--相关资源模块-->
        <div *ngIf=" MODE == 'resource'">
          <nz-breadcrumb>
            <nz-breadcrumb-item><a  (click)="getTheResource('all')">All Resource</a></nz-breadcrumb-item>
            <nz-breadcrumb-item *ngIf="this.user.type === 'teacher' || this.user.type === 'admin'"><a (click)="getTheResource('my')">My Resource</a></nz-breadcrumb-item>
          </nz-breadcrumb>


          <nz-drawer [nzClosable]="false" [nzVisible]="visible" nzPlacement="right" nzTitle="上传信息表"  (nzOnClose)="close()">
            <form>
              <div nz-col nzSpan="18">
                <label>作者：</label>
                <input type="text" nz-input [(ngModel)]="author" name="author" />
              </div>
              <div nz-col nzSpan="18">
                <label>资源名称</label>
                <input type="text" nz-input [(ngModel)]="resourceName" name="resourceName" />
              </div>
              <div nz-col nzSpan="18">
                <label>模块属于</label>
                <nz-radio-group [(ngModel)]="theModelName" [ngModelOptions]="{standalone: true}">
                  <label nz-radio nzValue='知识点'>知识点</label>
                  <label nz-radio nzValue='java工具'>java工具</label>
                </nz-radio-group>
              </div>
            </form>
            <nz-upload
              nzAction="http://localhost:8080/upload/"
              [nzName]="fileName"
              [nzCustomRequest]="customReq">
              <button nz-button>
                <i nz-icon type="upload"></i><span>Click to Upload</span>
              </button>
            </nz-upload>
            <div class="footer">
              <button type="button" (click)="close()" class="ant-btn" style="margin-right: 8px;"><span>Cancel</span></button>
              <button type="button" (click)="upload()" class="ant-btn ant-btn-primary"><span>Submit</span></button>
            </div>
          </nz-drawer>

          <nz-table #basicTable [nzData]="theResource" [nzLoading]="loading">
            <thead>
            <tr>
              <th>Author</th>
              <th>ResourceName</th>
              <th>modelName</th>
              <th>Action</th>
            </tr>
            </thead>
            <tbody>
            <tr *ngFor="let data of basicTable.data">
              <td>{{data.author}}</td>
              <td>{{data.resourcename}}</td>
              <td>{{data.type}}</td>
              <td><a href="http://localhost:8080/download?fileName={{data.url}}" ><i nz-icon type="download" theme="outline"></i></a></td>
            </tr>
            </tbody>
          </nz-table>

          <div>

          </div>
        </div>

        <!--在线测试模块-->
        <div *ngIf="MODE =='exam'">
          <!--切换编辑模式-->
          <div *ngIf="this.user.type === 'teacher' || this.user.type === 'admin'">
          <label>编辑模式：</label>
          <nz-switch [(ngModel)]="isEdit" nzCheckedChildren="开" nzUnCheckedChildren="关"></nz-switch>
          </div>
          <!--exam-->
          <div *ngIf="isEdit">
            <nz-breadcrumb>
              <nz-breadcrumb-item>
                <a (click)="CHOOSE='exam'">题目管理</a>
              </nz-breadcrumb-item>
              <nz-breadcrumb-item>
                <a (click)="CHOOSE='test'">试卷管理</a>
              </nz-breadcrumb-item>
            </nz-breadcrumb>
            <!--exam-->
            <div *ngIf="CHOOSE=='exam'">
            <div>
              <button nz-button [nzType]="'primary'" (click)="showModal()"><span>上传题目</span></button>
              <nz-modal [(nzVisible)]="isVisible" nzTitle="新建题目" nzMask="true" (nzOnCancel)="handleCancel()" (nzOnOk)="handleOk()">
                <p>题目：<input [(ngModel)]="examModal.question"/></p>
                <p>题型：<nz-select style="width: 120px;" [(ngModel)]="examModal.type"nzPlaceHolder="Choose">
                        <nz-option nzValue="选择题" nzLabel="选择题"></nz-option>
                        <nz-option nzValue="填空题" nzLabel="填空题"></nz-option>
                        </nz-select></p>
                <p>a选项：   <input [(ngModel)]="examModal.a"/></p>
                <p>b选项：   <input [(ngModel)]="examModal.b"/></p>
                <p>c选项：   <input [(ngModel)]="examModal.c"/></p>
                <p>正确答案：<input [(ngModel)]="examModal.answer"/></p>
                <p>分值：    <input [(ngModel)]="examModal.grade"/></p>
              </nz-modal>
            </div>
            <div style="padding:24px; background: #fff; min-height: 400px;">
              <!--table-->
              <nz-table #nzTable [nzData]="exam" [nzLoading]="loading">
                <thead>
                <tr>
                  <th>题目类型</th>
                  <th >试题分值</th>
                  <th>试题</th>
                  <th>A选项</th>
                  <th>B选项</th>
                  <th>C选项</th>
                </tr>
                </thead>
                <tbody>
                <tr *ngFor="let data of nzTable.data">
                  <td>{{data.type}}</td>
                  <td>{{data.grade}}</td>
                  <td>{{data.question}}</td>
                  <td>{{data.a}}</td>
                  <td>{{data.b}}</td>
                  <td>{{data.c}}</td>
                </tr>
                </tbody>
              </nz-table>
            </div>
            </div>
            <!--testPaper-->
            <div *ngIf="CHOOSE=='test'">
              <div>
                <button nz-button [nzType]="'primary'" (click)="showModal()"><span>新建试卷</span></button>
                <nz-modal [(nzVisible)]="isVisible" nzTitle="新试卷" (nzOnCancel)="handleCancel()" (nzOnOk)="handleOk()">
                  <p>试卷名称：<input [(ngModel)]="examName"/></p>
                  <p>题目<nz-select style="width: 100%" [(ngModel)]="multipleValue" [nzSize]="size" nzMode="multiple" nzPlaceHolder="Please select">
                    <nz-option *ngFor="let option of listOfOption" [nzLabel]="option.label" [nzValue]="option.value"></nz-option>
                  </nz-select></p>
                  <p>难度：<nz-select style="width: 120px;" [(ngModel)]="selectedValue" nzPlaceHolder="Choose">
                    <nz-option nzValue="简单" nzLabel="简单" name=""></nz-option>
                    <nz-option nzValue="中等" nzLabel="中等"></nz-option>
                    <nz-option nzValue="难" nzLabel="难"></nz-option>
                  </nz-select></p>
                  <p>备注：<input [(ngModel)]="remark"/></p>
                </nz-modal>
              </div>
            <div style="padding:24px; background: #fff; min-height: 400px;">
              <!--table-->
              <nz-table #nzPaper [nzData]="testPaperList"  [nzLoading]="loading">
                <thead>
                <tr>
                  <th>作者</th>
                  <th >试卷名称</th>
                  <th>试卷难度</th>
                  <th>备注</th>
                </tr>
                </thead>
                <tbody>
                <tr *ngFor="let data of nzPaper.data">
                  <td>{{data.author}}</td>
                  <td>{{data.name}}</td>
                  <td>{{data.difficulty}}</td>
                  <td>{{data.remark}}</td>
                </tr>
                </tbody>
              </nz-table>

            </div>
          </div>
        </div>
          <div *ngIf="!isEdit">
            <!--选择试卷-->
            <div *ngIf="!isTest">
            <nz-table #nzPaper [nzData]="testPaperList"  [nzLoading]="loading">
              <thead>
              <tr>
                <th>作者</th>
                <th >试卷名称</th>
                <th>试卷难度</th>
                <th>备注</th>
                <th>选择</th>
              </tr>
              </thead>
              <tbody>
              <tr *ngFor="let data of nzPaper.data">
                <td>{{data.author}}</td>
                <td>{{data.name}}</td>
                <td>{{data.difficulty}}</td>
                <td>{{data.remark}}</td>
                <td><a (click)="isTest=true;loading=true;setTheTest(data.id);loading=false"><i nz-icon type="edit" theme="twotone"></i></a></td>
              </tr>
              </tbody>
            </nz-table>
            </div>
            <!--指定试卷-->
            <div *ngIf="isTest">
              <nz-table #nzTable [nzData]="theTest" [nzLoading]="loading" [nzShowPagination]="false">
                <tbody *ngFor="let data of nzTable.data">
                <tr>
                  <td colspan="3">{{data.question}}</td>
                </tr>
                <tr>
                  <nz-radio-group [(ngModel)]="data.answer">
                    <td> <label nz-radio nzValue="A">A{{data.a}}</label></td>
                    <td> <label nz-radio nzValue="B">B{{data.b}}</label></td>
                    <td> <label nz-radio nzValue="C">C{{data.c}}</label></td>
                  </nz-radio-group>
                </tr>
                <br/>
                </tbody>
              </nz-table>
              <button (click)="this.getGrade()">交卷</button>
            </div>
          </div>
        </div>
        <!--修改密码模块-->
        <div >
          <nz-drawer [nzClosable]="false" [nzVisible]="Pvisible" nzPlacement="top" nzTitle="修改密码" (nzOnClose)="close()">
           <p><label>当前用户</label>
            <input value="{{this.user.loginname}}" readonly> </p>
            <p><label>新密码：</label>
            <input [(ngModel)]="this.user.password"> </p>
            <p><button nz-button nzType="primary"  (click)="update()">修改</button></p>
          </nz-drawer>
        </div>
      </nz-content>

    </nz-layout>

  </nz-layout>
