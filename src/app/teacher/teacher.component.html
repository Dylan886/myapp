<nz-layout class="layout">
  <nz-header>
    <div class="logo">{{username}}</div>
    <ul nz-menu [nzTheme]="'dark'" [nzMode]="'horizontal'" style="line-height: 64px;">
      <li nz-menu-item (click)="MODE ='main'">主页</li>
      <li nz-menu-item (click)="MODE ='addition';Sider='1'">知识点学习</li>
      <li nz-menu-item (click)="MODE ='advanced'">拓展知识</li>
      <li nz-menu-item (click)="MODE ='fundament';Sider='1'">集合框架</li>
      <li nz-menu-item (click)="MODE ='resource'">相关资源</li>
      <li nz-menu-item (click)="MODE ='exam';this.getExam();this.getTestPaper()">在线测试</li>
      <li nz-menu-item *ngIf="this.user.type !== 'tourist'" (click)="Pvisible=true">修改密码</li>
      <li nz-menu-item *ngIf="this.user.type !== 'tourist'" ><a href="login">注销</a></li>
      <li nz-menu-item *ngIf="this.user.type === 'tourist'"><a href="login">登陆</a> </li>
    </ul>
  </nz-header>

  <nz-layout style="margin: 30px 20px 30px 20px">

    <!--// 侧边栏-->
    <nz-sider [nzWidth]="200" style="background:#fff">

      <!--知识点的侧边栏-->
      <div *ngIf="MODE == 'addition'">
        <ul nz-menu [nzMode]="'inline'" style="height:100%">
          <li nz-submenu>
            <span title><i nz-icon type="user"></i>JAVA基础</span>
            <ul>
              <li nz-menu-item (click)="Sider ='1'">Java简介</li>
              <li nz-menu-item (click)="Sider ='2'">Java基本数据类型</li>
              <li nz-menu-item (click)="Sider ='3'">Java 变量类型</li>
            </ul>
          </li>
          <li nz-submenu>
            <span title><i nz-icon type="user"></i>JAVA三大特性</span>
            <ul>
              <li nz-menu-item (click)="Sider ='4'">Java继承</li>
              <li nz-menu-item (click)="Sider ='5'">Java多态</li>
              <li nz-menu-item (click)="Sider ='6'">Java封装</li>
            </ul>
          </li>
          <li nz-submenu>
            <span title><i nz-icon type="user"></i>JAVA算法</span>
            <ul>
              <li nz-menu-item (click)="Sider ='7'">分治法</li>
              <li nz-menu-item (click)="Sider ='8'">贪心算法</li>
              <li nz-menu-item (click)="Sider ='9'">动态规划算法</li>
              <li nz-menu-item (click)="Sider ='10'">回溯法</li>
              <li nz-menu-item (click)="Sider ='11'">分支限界法</li>
            </ul>
          </li>
          <li nz-submenu>
            <span title><i nz-icon type="user"></i>JAVA设计模式</span>
            <ul>
              <li nz-menu-item (click)="Sider ='12'">Java继承</li>
              <li nz-menu-item (click)="Sider ='13'">Java多态</li>
              <li nz-menu-item (click)="Sider ='14'">Java封装</li>
            </ul>
          </li>
        </ul>
      </div>

      <!--拓展知识的侧边栏-->
      <div *ngIf="MODE == 'advanced'">
        <!--提取知识点的名称，并push入侧边栏 "> </div>-->
        <ul nz-menu [nzMode]="'inline'" style="height:100%">
          <li nz-menu-item *ngFor="let s of this.sider" ><p (click)="changeSelected(s)">{{s}}</p>></li>
        </ul>
      </div>

      <!--集合框架的侧边栏-->
      <div *ngIf="MODE == 'fundament'">
        <ul nz-menu [nzMode]="'inline'" style="height:100%">
          <li nz-menu-item (click)="Sider ='1'">Java简介</li>
          <li nz-menu-item (click)="Sider ='2'">Java发展历史</li>
          <li nz-menu-item (click)="Sider ='3'">Java对象和类</li>
          <li nz-menu-item (click)="Sider ='4'">Java基本数据类型</li>
          <li nz-menu-item (click)="Sider ='5'">Java变量类型</li>
          <li nz-menu-item (click)="Sider ='6'">Java修饰符</li>
          <li nz-menu-item (click)="Sider ='7'">Java运算符</li>
          <li nz-menu-item (click)="Sider ='8'">Java循环结构</li>
          <li nz-menu-item (click)="Sider ='9'">Java语句结构</li>
        </ul>
      </div>

      <!--相关资源的侧边栏-->
      <div *ngIf=" MODE == 'resource'">
        <button nz-button nzType="primary" (click)="open()">Open</button>
      </div>

    </nz-sider>

    <!--// 主体-->
    <nz-layout >

      <nz-content style="background: #ffffff; padding: 24px; min-height: 650px;">
        <!--主页内容-->
        <div *ngIf="MODE =='main'">
          <!--步骤条-->
          <div style=" padding: 20px 200px 20px 0px">
            <h1>Java 学习之路</h1>
            <nz-steps>
              <nz-step nzTitle="Finished" nzDescription="基础知识"></nz-step>
              <nz-step nzTitle="In Progress" nzDescription="进阶知识"></nz-step>
              <nz-step nzTitle="Waiting" nzDescription="实例教程"></nz-step>
            </nz-steps>
          </div>
          <!--卡片-->
          <div style="background: inherit;">
            <div nz-row [nzGutter]="8">
              <div nz-col [nzSpan]="8">
                <nz-card nzHoverable style="width:240px;height: 400px" [nzCover]="coverTemplate1">
                  <nz-card-meta nzTitle="最全的Java基础知识" nzDescription="了解Java的发展史以及各种技术操作"></nz-card-meta>
                </nz-card>
                <ng-template #coverTemplate1>
                  <img alt="example" src="../../assets/img/java1.png" (click)="MODE='addition'" />
                </ng-template>
              </div>
              <div nz-col [nzSpan]="8">
                <nz-card nzHoverable style="width:240px;height: 400px" [nzCover]="coverTemplate2">
                  <nz-card-meta nzTitle="最前沿的Java技术" nzDescription="助你在Java之路快人一步"></nz-card-meta>
                </nz-card>
                <ng-template #coverTemplate2>
                  <img alt="example" src="../../assets/img/java2.png" (click)="MODE='advanced'" />
                </ng-template>
              </div>
              <div nz-col [nzSpan]="8">
                <nz-card nzHoverable style="width:240px;height: 400px" [nzCover]="coverTemplate3">
                  <nz-card-meta nzTitle="最直观地的用例教学" nzDescription="轻松巩固之前所学"></nz-card-meta>
                </nz-card>
                <ng-template #coverTemplate3>
                  <img alt="example" src="../../assets/img/java3.png" (click)="MODE='fundament'" />
                </ng-template>
              </div>
            </div>
          </div>
          <!--知识点-->
          <div style=" padding: 50px 180px 20px 0px">
            <h1>推荐知识点</h1>
            <div style="background: #ECECEC;padding:30px;">
              <div nz-row [nzGutter]="8" *ngFor="let a of newResource">
                <div nz-col [nzSpan]="8">
                  <nz-card nzTitle="{{a.resourcename}}">
                  </nz-card>
                </div>
              </div>
            </div>
          </div>
          <!--工具-->
          <div style=" padding: 50px 180px 20px 0px">
            <h1>推荐工具</h1>
            <div style="background: #ECECEC;padding:30px;">
              <div nz-row [nzGutter]="8">
                <div nz-col [nzSpan]="8">
                  <nz-card nzTitle="Card title">
                    <p>Card content</p>
                  </nz-card>
                </div>
                <div nz-col [nzSpan]="8">
                  <nz-card nzTitle="Card title">
                    <p>Card content</p>
                  </nz-card>
                </div>
                <div nz-col [nzSpan]="8">
                  <nz-card nzTitle="Card title">
                    <p>Card content</p>
                  </nz-card>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!--知识点模块-->
        <div *ngIf="MODE =='addition'">

          <div *ngIf=" Sider == '1'">

            <h1>Java简介</h1>
            <h3>Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。</h3>

            <h3>由James Gosling和同事们共同研发，并在1995年正式推出。</h3>

            <h3>Java分为三个体系：</h3><br />
            <nz-timeline style="font-size: 30px">
              <nz-timeline-item>JavaSE（J2SE）（Java2 Platform Standard Edition，java平台标准版）</nz-timeline-item>
              <nz-timeline-item>JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版)</nz-timeline-item>
              <nz-timeline-item>JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)。</nz-timeline-item>
            </nz-timeline>
            <h3>2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名以取消其中的数字"2"：J2EE更名为Java EE,</h3>
              <h3>J2SE更名为Java SE，J2ME更名为Java ME。</h3>
          </div>

          <div *ngIf=" Sider == '2'">

            <h1>Java 基本数据类型</h1>
            <p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。</p>
            <p>内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。</p>
            <p>
              <img src="//www.runoob.com/wp-content/uploads/2013/12/memorypic1.jpg"></p>
            <p>因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。</p>
            <p>Java 的两大数据类型:</p>
            <ul><li>内置数据类型</li>
              <li>引用数据类型</li>
            </ul><hr>
            <h2>内置数据类型</h2>
            <p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 </p>
            <p><strong>byte：</strong></p>
            <ul>
              <li>
                byte 数据类型是8位、有符号的，以二进制补码表示的整数；</li>
              <li>
                最小值是 <span class="marked">-128（-2^7）</span>；</li>
              <li>
                最大值是 <span class="marked">127（2^7-1）</span>；</li>
              <li>
                默认值是 <span class="marked">0</span>；</li>
              <li>
                byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；</li>
              <li>
                例子：byte a = 100，byte b = -50。</li>
            </ul><p><strong>short：</strong></p>
            <ul>
              <li>
                short 数据类型是 16 位、有符号的以二进制补码表示的整数</li>
              <li>
                最小值是 <span class="marked">-32768（-2^15）</span>；</li>
              <li>
                最大值是 <span class="marked">32767（2^15 - 1）</span>；</li>
              <li>
                Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；</li>
              <li>
                默认值是 <span class="marked">0</span>；</li>
              <li>
                例子：short s = 1000，short r = -20000。</li>
            </ul>
            <p><strong>int：</strong></p>
            <ul>
              <li>
                int 数据类型是32位、有符号的以二进制补码表示的整数；</li>
              <li>
                最小值是 <span class="marked">-2,147,483,648（-2^31）</span>；</li>
              <li>
                最大值是 <span class="marked">2,147,483,647（2^31 - 1）</span>；</li>
              <li>
                一般地整型变量默认为 int 类型；</li>
              <li>
                默认值是 <span class="marked">0</span> ；</li>
              <li>
                例子：int a = 100000, int b = -200000。</li>
            </ul>
            <p><strong>long：</strong></p>
            <ul>
              <li>
                long 数据类型是 64 位、有符号的以二进制补码表示的整数；</li>
              <li>
                最小值是 <span class="marked">-9,223,372,036,854,775,808（-2^63）</span>；</li>
              <li>
                最大值是 <span class="marked">9,223,372,036,854,775,807（2^63 -1）</span>；</li>
              <li>
                这种类型主要使用在需要比较大整数的系统上；</li>
              <li>
                默认值是 <span class="marked">0L</span>；</li>
              <li>
                例子： long a = 100000L，Long b = -200000L。<br>
                "L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写。
              </li>
            </ul>
            <p><strong>float：</strong></p>
            <ul>
              <li>
                float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li>
              <li>
                float 在储存大型浮点数组的时候可节省内存空间；</li>
              <li>
                默认值是 <span class="marked">0.0f</span>；</li>
              <li>
                浮点数不能用来表示精确的值，如货币；</li>
              <li>
                例子：float f1 = 234.5f。</li>
            </ul>
            <p><strong>double：</strong></p>
            <ul>
              <li>
                double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；</li>
              <li>
                浮点数的默认类型为double类型；</li>
              <li>
                double类型同样不能表示精确的值，如货币；</li>
              <li>
                默认值是 <span class="marked">0.0d</span>；</li>
              <li>
                例子：double d1 = 123.4。</li>
            </ul>
            <p><strong>boolean：</strong></p>
            <ul>
              <li>
                boolean数据类型表示一位的信息；</li>
              <li>
                只有两个取值：true 和 false；</li>
              <li>
                这种类型只作为一种标志来记录 true/false 情况；</li>
              <li>
                默认值是 <span class="marked">false</span>；</li>
              <li>
                例子：boolean one = true。</li>
            </ul>
            <p><strong>char：</strong></p>
            <ul>
              <li>
                char类型是一个单一的 16 位 Unicode 字符；</li>
              <li>
                最小值是 <span class="marked">\u0000</span>（即为0）；</li>
              <li>
                最大值是 <span class="marked">\uffff</span>（即为65,535）；</li>
              <li>
                char 数据类型可以储存任何字符；</li>
              <li>
                例子：char letter = 'A';。</li>
            </ul>
          </div>

          <div *ngIf=" Sider == '3'">

            <h1>Java 变量类型</h1>
            <p>Java语言支持的变量类型有：</p>
            <ul>
              <li>
                类变量：独立于方法之外的变量，用 static 修饰。</li>
              <li>
                实例变量：独立于方法之外的变量，不过没有 static 修饰。  </li>
              <li>
                局部变量：类的方法中的变量。</li>
            </ul>
            <hr>
            <h2>Java 局部变量</h2>
            <ul>
              <li>
                局部变量声明在方法、构造方法或者语句块中；</li>
              <li>
                局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li>
              <li>
                访问修饰符不能用于局部变量；</li>
              <li>
                局部变量只在声明它的方法、构造方法或者语句块中可见；</li>
              <li>
                局部变量是在栈上分配的。</li>
              <li>
                局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li>
            </ul>
            <hr>
            <h2>实例变量</h2>
            <ul>
              <li>
                实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li>
              <li>
                当一个对象被实例化之后，每个实例变量的值就跟着确定；</li>
              <li>
                实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</li>
              <li>
                实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li>
              <li>
                实例变量可以声明在使用前或者使用后；</li>
              <li>
                访问修饰符可以修饰实例变量；</li>
              <li>
                实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li>
              <li>
                实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li>
              <li>
                实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</li>
            </ul>
            <hr>
            <h2>类变量（静态变量）</h2>
            <ul>
              <li>
                类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。</li>
              <li>
                无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li>
              <li>
                静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。</li>
              <li>
                静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。</li>
              <li>
                静态变量在第一次被访问时创建，在程序结束时销毁。</li>
              <li>
                与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。</li>
              <li>
                默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li>
              <li>
                静态变量可以通过：<em>ClassName.VariableName</em>的方式访问。</li>
              <li>
                类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</li>
            </ul>



          </div>

          <div *ngIf=" Sider == '4'">

            <h1>Java 继承</h1>
            <h2>继承的概念</h2><p>
            继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p>
            <p>
              继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。
            </p>
            <h3>生活中的继承：
            </h3>

            <p><img src="//www.runoob.com/wp-content/uploads/2013/12/14B0951E-FC75-47A3-B611-4E1883887339.jpg"></p>
            <p>兔子和羊属于食草动物类，狮子和豹属于食肉动物类。</p><p>
            食草动物和食肉动物又是属于动物类。</p><p>
            所以继承需要符合的关系是：is-a，父类更通用，子类更具体。</p><p>
            虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以子类会具有父类的一般特性也会具有自身的特性。</p>
            <h3>继承类型
            </h3>
            <p>需要注意的是 Java 不支持多继承，但支持多重继承。</p>
            <p><img src="//www.runoob.com/wp-content/uploads/2013/12/types_of_inheritance.png"></p>
            <hr>
            <h2>继承的特性</h2><ul><li><p>
            子类拥有父类非 private 的属性、方法。</p></li><li><p>
            子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</p></li><li><p>
            子类可以用自己的方式实现父类的方法。</p></li><li><p>
            Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</p></li><li><p>
            提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</p></li></ul>
            <hr>
            <h2>继承关键字
            </h2>
            <p>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 <strong>java.lang</strong> 包中，所以不需要 <strong>import</strong>）祖先类。</p>
            <h3>extends关键字</h3>
            <p>在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。</p>

          </div>

          <div *ngIf=" Sider == '5'">
            <h1>Java 多态</h1>
            <hr>

            <p>多态是同一个行为具有多个不同表现形式或形态的能力。</p>
            <p>多态就是同一个接口，使用不同的实例而执行不同操作，如图所示：</p>
            <p><img src="//www.runoob.com/wp-content/uploads/2013/12/dt-java.png"></p>
            <p>多态性是对象多种表现形式的体现。</p>

            <blockquote>
              <p>现实中，比如我们按下 F1 键这个动作：
              </p>
              <ul><li>
                如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；</li><li>如果当前在 Word 下弹出的就是 Word 帮助；</li><li>在 Windows 下弹出的就是 Windows 帮助和支持。</li></ul><p>同一个事件发生在不同的对象上会产生不同的结果。</p>
            </blockquote>
            <h3>
              多态的优点
            </h3><ul><li>
            1. 消除类型之间的耦合关系</li><li>
            2. 可替换性</li><li>
            3. 可扩充性</li><li>
            4. 接口性</li><li>
            5. 灵活性</li><li>
            6. 简化性</li></ul>

            <h3>多态存在的三个必要条件</h3>
            <ul><li>继承</li><li>重写</li><li>父类引用指向子类对象</li></ul><p>
            比如：</p><pre>Parent p = new Child();</pre>
            <p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。</p>
            <p>多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p>
            <h3>重写</h3>
            <p>我们将介绍在 Java 中，当设计类时，被重写的方法的行为怎样影响多态性。</p><p>
            我们已经讨论了方法的重写，也就是子类能够重写父类的方法。</p><p>
            当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。</p><p>
            要想调用父类中被重写的方法，则必须使用关键字 <strong>super</strong>。</p>
            <hr>
            <h2>多态的实现方式</h2>
            <h3>方式一：重写
            </h3>

            <h3>方式二：接口
            </h3>
            <ul><li><p>
              1. 生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。</p></li><li><p>
              2. java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。</p></li></ul>
            <h3>
              方式三：抽象类和抽象方法</h3>
          </div>

          <div *ngIf=" Sider == '6'">

            <h1>Java 封装</h1>
            <hr>

            <p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。
            </p>
            <p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p><p>
            要访问该类的代码和数据，必须通过严格的接口控制。</p><p>
            封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p><p>
            适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p>
            <h3>封装的优点</h3>
            <ul>

              <li><p>
                1. 良好的封装能够减少耦合。</p></li><li><p>
              2. 类内部的结构可以自由修改。</p></li><li><p>
              3. 可以对成员变量进行更精确的控制。</p></li><li><p>
              4. 隐藏信息，实现细节。</p></li>

            </ul>

          </div>

          <div *ngIf="Sider == '7'">
            <p style="margin-left:0pt;">算法一：分治法</p>

            <ul><li>基本概念</li>
            </ul><p><span style="color:#333333;">1.</span><span style="color:#333333;">把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</span></p>

            <p><span style="color:#333333;">2.</span><span style="color:#333333;">分治策略是对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解</span><span style="color:#333333;">。</span></p>

            <ul><li>适用情况</li>
            </ul><p><span style="color:#333333;">1</span><span style="color:#333333;">)该问题的规模缩小到一定的程度就可以容易地解决</span></p>

            <p><span style="color:#333333;">2</span><span style="color:#333333;">)该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</span></p>

            <p><span style="color:#333333;">3</span><span style="color:#333333;">)利用该问题分解出的子问题的解可以合并为该问题的解；</span></p>

            <p><span style="color:#333333;">4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</span></p>

            <ul><li>分治法的复杂性分析</li>
            </ul>
            <p><span style="color:#333333;">一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：</span></p>

            <p><span style="color:#333333;">T（n）= k T(n/m)+f(n)</span></p>

            <p><span style="color:#333333;">通过迭代法求得方程的解：</span></p>

            <p><span style="color:#333333;">递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当                  mi≤n&lt;mi+1时，T(mi)≤T(n)&lt;T(mi+1)。</span></p>

            <ul><li>分治法例题：合并排序和快速排序</li>
            </ul>
       <!--     <pre class="has">
<code>public class 分治_合并排序 {
	/**
	 * 函数说明：在数组被拆分以后进行合并
	 */
	static void Merge(int a[], int left, int middle, int rigth) {
		//定义左端数组大小
		int n1 = middle - left+1;
		int n2 = rigth - middle;

		//初始化数组，分配内存
		int bejin[] = new int[n1];
		int end[] = new int[n2];

		//数组赋值
		for(int i = 0; i &lt; n1; i++)
			bejin[i] = a[left + i];

		for(int i = 0; i &lt; n2; i++)
			end[i] = a[middle+1+i];

		//用key做原数组索引，没调用一次函数重新给原数组付一次值
		int i = 0, j = 0, key;
		for(key = left; key &lt;= rigth; key++){

			if(n1&gt;i&amp;&amp;n2&gt;j&amp;&amp;i &lt; n1 &amp;&amp; bejin[i] &lt;= end[j])
				a[key] = bejin[i++];
			else if(n1&gt;i&amp;&amp;n2&gt;j&amp;&amp;j &lt; n2 &amp;&amp; bejin[i] &gt;= end[j])
				a[key] = end[j++];
			else if(i == n1 &amp;&amp; j &lt; n2)
				a[key] = end[j++];
			else if(j == n2 &amp;&amp; i &lt; n1)
				a[key] = bejin[i++];
		}
	}
	/**
	 * 差分数组区间，不断分支
	 */
	static void MergeSort(int a[],int left,int rigth) {
		int middle=0;
		if(left&lt;rigth) {
			middle =(rigth+left)/2;
			MergeSort(a, left, middle);
			MergeSort(a, middle+1, rigth);
			Merge(a, left, middle, rigth);
		}
	}
	public static void main(String[] args) {
		int a[]= {85,3,52,9,7,1,5,4};
		MergeSort(a, 0,7);
		for(int i=0;i&lt;8;i++) {
			System.out.print(" "+a[i]);
		}

	}
}</code></pre>

            <pre class="has">
<code>public class 分治_快速排序 {
	/**
	 *交换函数，i，j为数组索引
	 */
	static void swap(int A[], int i, int j)
	{
	    int temp = A[i];
	    A[i] = A[j];
	    A[j] = temp;
	}
	/**
	 * 选取一个关键字(key)作为枢轴，一般取整组记录的第一个数/最后一个，这里采用选取序列最后一个数为枢轴。
	 * 设置两个变量left = 0;right = N - 1;
	 * 从left一直向后走，直到找到一个大于key的值，right从后至前，直至找到一个小于key的值，然后交换这两个数。
	 * 重复第三步，一直往后找，直到left和right相遇，这时将key放置left的位置即可。
	 * @return
	 */
	static int PartSort(int[] array,int left,int right)
	{
	    int key = array[right];//定义基准
	    int count=right;//保存rigth值
	    while(left &lt; right)//防止数组越界
	    {
	        while(left &lt; right &amp;&amp; array[left] &lt;= key)
	        {
	            ++left;
	        }
	        while(left &lt; right &amp;&amp; array[right] &gt;= key)
	        {
	            --right;
	        }
	        swap(array,left,right);
	    }
	    swap(array,right,count);
	    return right;
	}
	/**
	 *分治思想，递归调用
	 */
	static void QuickSort(int array[],int left,int right)
	{
	    if(left &gt;= right)//表示已经完成一个组
	    {
	        return;
	    }
	    int index = PartSort(array,left,right);//枢轴的位置
	    QuickSort(array,left,index - 1);
	    QuickSort(array,index + 1,right);
	}
	public static void main(String[] args) {
		int a[]= {1,5,-5,54,15,67,16,23};
		QuickSort(a,0,7);
		for(int i=0;i&lt;a.length;i++) {
			System.out.print(" "+a[i]);
		}
	    System.out.print("\n");
	}
}</code></pre> -->

          </div>
          <div *ngIf="Sider == '8'">
            <blockquote>
              <p style="margin-left:0pt;">算法二：<span style="color:#333333;">贪心算法</span></p>
            </blockquote>

            <p style="margin-left:0pt;">一、基本概念：</p>

            <p><span style="color:#333333;">所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。</span></p>

            <p><span style="color:#333333;">贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</span></p>

            <p><span style="color:#333333;">所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</span></p>

            <p style="margin-left:0pt;">二、贪心算法的基本思路：</p>

            <p><span style="color:#333333;">1.建立数学模型来描述问题。</span></p>

            <p><span style="color:#333333;">2.把求解的问题分成若干个子问题。</span></p>

            <p><span style="color:#333333;">3.对每一子问题求解，得到子问题的局部最优解。</span></p>

            <p><span style="color:#333333;">4.把子问题的解局部最优解合成原来解问题的一个解</span><span style="color:#333333;">。</span></p>

            <p style="margin-left:0pt;">三、贪心算法适用的问题</p>

            <p><span style="color:#333333;">贪心策略适用的前提是：局部最优策略能导致产生全局最优解。</span></p>

            <p><span style="color:#333333;">实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</span></p>

            <p style="margin-left:0pt;">四、贪心算法的实现框架</p>

            <p><span style="color:#333333;">从问题的某一初始解出发；</span></p>

            <p><span style="color:#333333;">while （能朝给定总目标前进一步）</span></p>

            <p><span style="color:#333333;">利用可行的决策，求出可行解的一个解元素；</span></p>

            <p><span style="color:#333333;">由所有解元素组合成问题的一个可行解；  </span></p>

            <p style="margin-left:0pt;">五、贪心策略的选择</p>

            <p><span style="color:#333333;">因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。</span></p>

            <ul><li>贪心策略例题：prim算法</li>
            </ul>
            <!--      <pre class="has">
      <code>import java.util.*;
      public class 贪心算法_prim算法 {
          static int MAX = Integer.MAX_VALUE;
          public static void main(String[] args) {
              //定义无向图矩阵
              int[][] map = new int[][] {
                      { 0, 1, 6, 2},
                      { 1, 0, 3, 2},
                      { 6, 3, 0, 1},
                      { 2, 2, 1, 0}
                      };
              prim(map, map.length);
          }
          public static void prim(int[][] graph, int n){
                  //定义节点名字
                  char[] c = new char[]{'A','B','C','D'};
                  int[] lowcost = new int[n];  //到新集合的最小权
                  int[] mid= new int[n];//存取前驱结点
                  List&lt;Character&gt; list=new ArrayList&lt;Character&gt;();//用来存储加入结点的顺序
                  int i, j, min, minid , sum = 0;
                  //初始化辅助数组
                  for(i=1;i&lt;n;i++)
                  {
                      lowcost[i]=graph[0][i];
                      mid[i]=0;
                  }
                  list.add(c[0]);
                  //一共需要加入n-1个点
                  for(i=1;i&lt;n;i++)
                  {
                       min=MAX;
                       minid=0;
                       //每次找到距离集合最近的点
                       for(j=1;j&lt;n;j++)
                       {
                           if(lowcost[j]!=0&amp;&amp;lowcost[j]&lt;min)
                           {
                               min=lowcost[j];
                               minid=j;
                           }
                       }
                       if(minid==0) return;
                       list.add(c[minid]);
                       lowcost[minid]=0;
                       sum+=min;
                       System.out.println(c[mid[minid]] + "到" + c[minid] + " 权值：" + min);
                       //加入该点后，更新其它点到集合的距离
                       for(j=1;j&lt;n;j++)
                       {
                           if(lowcost[j]!=0&amp;&amp;lowcost[j]&gt;graph[minid][j])
                           {
                               lowcost[j]=graph[minid][j];
                               mid[j]=minid;
                           }
                       }
                       System.out.print("\n");
                  }
                  System.out.println("sum:" + sum);
              }
      }
      </code></pre>-->

          </div>

          <div *ngIf="Sider == '9'">
            <blockquote>
              <p style="margin-left:0pt;">算法三：动态规划算法</p>
            </blockquote>

            <p style="margin-left:0pt;">一、基本概念</p>

            <p>    <span style="color:#333333;">动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。</span></p>

            <p style="margin-left:0pt;">二、基本思想与策略</p>

            <p>    <span style="color:#333333;">基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</span></p>

            <p><span style="color:#333333;">    由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</span></p>

            <p><span style="color:#333333;">    与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</span></p>

            <p style="margin-left:0pt;">三、适用的情况</p>

            <p><span style="color:#333333;">能采用动态规划求解的问题的一般要具有3个性质：</span></p>

            <p><span style="color:#333333;">    (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</span></p>

            <p><span style="color:#333333;">    (2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</span></p>

            <p><span style="color:#333333;">   （3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</span></p>

            <p style="margin-left:0pt;">三、算法实例：背包问题</p>

            <!--       <pre class="has">
       <code>public class 动态规划_背包问题 {
       public static void main(String[] args) {
           //物品价值,重量,和背包承重
           int v[]={0,8,10,6,3,7,2};
           int w[]={0,4,6,2,2,5,1};
           int c=12;

           //定义二位数组动态规划背包价值和重量
           int m[][]=new int[v.length][c+1];
           for (int i = 1; i &lt;v.length; i++) {
               for (int j = 1; j &lt;=c; j++) {
                   if(j&gt;=w[i])
                       m[i][j]=m[i-1][j-w[i]]+v[i]&gt;m[i-1][j]?m[i-1][j-w[i]]+v[i]:m[i-1][j];
                   else
                       m[i][j]=m[i-1][j];
               }
           }
           int max=0;
           for (int i = 0; i &lt;v.length; i++) {
               for (int j = 0; j &lt;=c; j++) {
                   if(m[i][j]&gt;max)
                       max=m[i][j];
               }
           }
           System.out.println(max);
       }
       }</code></pre>-->


          </div>

          <div *ngIf="Sider == '10'">
            <blockquote>
              <p style="margin-left:0pt;">算法四：回溯法</p>
            </blockquote>

            <p style="margin-left:0pt;">1、概念</p>

            <p style="margin-left:0pt;">回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>

            <p style="margin-left:0pt;">回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>

            <p style="margin-left:0pt;">许多<span style="color:#333333;">复杂的，规模较大</span>的问题都可以使用回溯法，有“通用解题方法”的美称。</p>

            <p style="margin-left:0pt;">2、基本思想</p>

            <p style="margin-left:0pt;">在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。</p>

            <p style="margin-left:0pt;">若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。</p>

            <p style="margin-left:0pt;">而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p>

            <p style="margin-left:0pt;">3、用回溯法解题的一般步骤：</p>

            <p style="margin-left:0pt;"><span style="color:#333333;">（</span>1）针对所给问题，确定问题的解空间：</p>

            <p style="margin-left:0pt;">首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。</p>

            <p style="margin-left:0pt;">（2）确定结点的扩展搜索规则</p>

            <p style="margin-left:0pt;">（3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</p>

            <p style="margin-left:0pt;">4、算法实例：求子集问题</p>

            <!--  <pre class="has">
  <code>public class 回溯法_求子集问题 {
          private static int[] s = {2,2,3};
          private static int n = s.length;
          private static int[] x = new int[n];
          /**
           * 输出集合的子集
           * @param limit  决定选出特定条件的子集
           * 注：all为所有子集,num为限定元素数量的子集,
           *    sp为限定元素奇偶性相同，且和小于8。
           */
          public static void all_subset(String limit){
              switch(limit){
              case "all":backtrack(0);break;
              case "num":backtrack1(0);break;
              case "sp":backtrack2(0);break;
              }
          }
          /**
           * 回溯法求集合的所有子集，依次递归
           * 注：是否回溯的条件为精髓
           * @param t
           */
          private static void backtrack(int t){
              if(t &gt;= n)
                  output(x);
              else
                  for (int i = 0; i &lt;= 1; i++) {
                      x[t] = i;
                      backtrack(t+1);
                  }
          }
          /**
           * 回溯法求集合的所有(元素个数小于4)的子集，依次递归
           * @param t
           */
          private static void backtrack1(int t){
              if(t &gt;= n)
                  output(x);
              else
                  for (int i = 0; i &lt;= 1; i++) {
                      x[t] = i;
                      if(count(x, t) &lt; 4)
                          backtrack1(t+1);
                  }
          }

          /**
           * (剪枝)
           * 限制条件：子集元素小于4,判断0~t之间已被选中的元素个数，
           *        因为此时t之后的元素还未被递归,即决定之后的元素
           *        是否应该被递归调用
           * @param x
           * @param t
           * @return
           */
          private static int count(int[] x, int t) {
              int num = 0;
              for (int i = 0; i &lt;= t; i++) {
                  if(x[i] == 1){
                      num++;
                  }
              }
              return num;
          }
          /**
           * 回溯法求集合中元素奇偶性相同，且和小于8的子集,依次递归
           * @param t
           */
          private static void backtrack2(int t){
              if(t &gt;= n)
                  output(x);
              else
                  for (int i = 0; i &lt;= 1; i++) {
                      x[t] = i;
                      if(legal(x, t))
                          backtrack2(t+1);
                  }
          }
          /**
           * 对子集中元素奇偶性进行判断，还需元素的数组和小于8
           * @param x
           * @param t
           * @return
           */
          private static boolean legal(int[] x, int t) {
              boolean bRet = true;   //判断是否需要剪枝
              int part = 0;  //奇偶性判断的基准

              for (int i = 0; i &lt;= t; i++) {  //选择第一个元素作为奇偶性判断的基准
                  if(x[i] == 1){
                      part = i;
                      break;
                  }
              }
              for (int i = 0; i &lt;= t; i++) {
                  if(x[i] == 1){
                      bRet &amp;= ((s[part] - s[i]) % 2 == 0);
                  }
              }
              int sum = 0;
              for(int i = 0; i &lt;= t; i++){
                  if(x[i] == 1)
                      sum += s[i];
              }
              bRet &amp;= (sum &lt; 8);
              return bRet;
          }
          /**
           * 子集输出函数
           * @param x
           */
          private static void output(int[] x) {
              for (int i = 0; i &lt; x.length; i++) {
                  if(x[i] == 1){
                      System.out.print(s[i]);
                  }
              }
              System.out.println();
          }
        public static void main(String[] args) {
            all_subset("all");
      }
  } </code></pre> -->
          </div>

          <div *ngIf="Sider == '11'">
            <blockquote>
              <p style="margin-left:0pt;"><span style="color:#333333;">算法五：分支限界法</span></p>
            </blockquote>

            <p>一、基本描述</p>

            <p>    类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。<strong>回溯法的求解目标是找出T中满足约束条件的所有解</strong>，而<strong>分支限界法</strong>的求解目标则是找出<strong>满足约束条件的一个解</strong>，或是在满足约束条件的解中找出使某一目标函数值达到<strong>极大或极小的解</strong>，即在某种意义下的<strong>最优解</strong>。</p>

            <p>   （1）分支搜索算法</p>

            <p>    所谓“分支”就是采用广度优先的策略，依次搜索E-结点的所有分支，也就是所有相邻结点，抛弃不满足约束条件的结点，其余结点加入活结点表。然后从表中选择一个结点作为下一个E-结点，继续搜索。</p>

            <p>     选择下一个E-结点的方式不同，则会有几种不同的分支搜索方式。</p>

            <p>   1）FIFO搜索</p>

            <p>   2）LIFO搜索</p>

            <p>   3）优先队列式搜索</p>

            <p>（2）分支限界搜索算法 </p>

            <p>二、分支限界法的一般过程</p>

            <p>    由于求解目标不同，导致分支限界法与回溯法在解空间树T上的搜索方式也不相同。<strong>回溯法以深度优先的方式搜索解空间树T</strong>，而<strong>分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T</strong>。</p>

            <p>    分支限界法的<strong>搜索策略是</strong>：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。</p>

            <p>    分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。问题的<strong>解空间树是表示问题解空间的一棵有序树，常见的有子集树和排列树</strong>。在搜索问题的解空间树时，分支限界法与回溯法对当前扩展结点所使用的扩展方式不同。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，那些导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被子加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所求的解或活结点表为空时为止。</p>

            <p>三、回溯法和分支限界法的一些区别</p>

            <p>    有一些问题其实无论用回溯法还是分支限界法都可以得到很好的解决，但是另外一些则不然。也许我们需要具体一些的分析——到底何时使用分支限界而何时使用回溯呢？</p>

            <p>回溯法和分支限界法的一些区别：</p>

            <p>   方法对解空间树的搜索方式 <a href="http://www.storworld.com/" rel="nofollow">存储</a>结点的常用数据结构结点<a href="http://www.storworld.com/" rel="nofollow">存储</a>特性常用应用</p>

            <p>  回溯法深度优先搜索堆栈活结点的所有可行子结点被遍历后才被从栈中弹出找出满足约束条件的所有解</p>

            <p>  分支限界法广度优先或最小消耗优先搜索队列、优先队列每个结点只有一次成为活结点的机会找出满足约束条件的一个解或特定意义下的最优解</p>

            <!--        <pre class="has">
        <code>import java.util.Collections;

        import java.util.LinkedList;

        public class 分支界限法_求最大承重问题 {
            LinkedList&lt;HeapNode&gt; heap;
            public static class BBnode{
                BBnode parent;//父结点
                boolean leftChild;//左儿子结点标志
                //构造方法
                public BBnode(BBnode par,boolean ch){
                    parent=par;
                    leftChild=ch;
                }
            }
            /**
             * 输出函数，做调试用
             * @param list
             */
            public static void printReverse(LinkedList&lt;HeapNode&gt; list){
                for (int i=0;i&lt;list.size();i++) {
                    HeapNode aBnode=list.get(i);
                    System.out.print("#"+aBnode.uweight+"#"+aBnode.level+" ");
                }

                }
            /*
             * 最大优先队列中存储的活结点类型为HeapNode
             */
            public static class HeapNode implements Comparable{
                BBnode liveNode;
                int uweight;//活结点优先级（上界）
                int level;//活结点在子集树种所处的层序号
                //构造函数
                public HeapNode(BBnode node,int up,int lev){
                    liveNode=node;
                    uweight=up;
                    level=lev;
                }
                @Override
                public int compareTo(Object x) {//升序排列
                    int xu=((HeapNode)x).uweight;
                    if(uweight&lt;xu) return -1;
                    if(uweight==xu) return 0;
                    return 1;
                }
                public boolean equals(Object x){
                    return uweight==((HeapNode)x).uweight;
                }
            }
            public void addLiveNode(int up,int lev,BBnode par,boolean ch){
                //将活结点加入到表示活结点优先队列的最大堆H中
                BBnode b=new BBnode(par,ch);
                HeapNode node=new HeapNode(b,up,lev);
                heap.add(node);
                Collections.sort(heap);
            }
            public int maxLoading(int[] w,int c,int[] bestx){
                int count=0;
                //优先队列式分支限界法，返回最优重量，bestx返回最优解
                heap=new LinkedList&lt;HeapNode&gt;();
                int n=w.length-1;
                BBnode e=null;//当前扩展结点
                int i=1;//当前扩展结点所处的层
                int ew=0;//扩展结点所对应的载重量
                //定义剩余重量数组r
                int[] r=new int[n+1];
                for(int j=n-1;j&gt;0;j--) {
                    r[j]=r[j+1]+w[j+1];
                }
                //搜索子集空间树
                while(i!=n+1){
                    //非叶结点
                    //检查当前扩展结点的儿子结点
                    if(ew+w[i]&lt;=c){
                        //左儿子结点为可行结点
                        addLiveNode(ew+w[i]+r[i],i+1,e,true);
                    }
                    //右儿子结点总为可行结点
                    addLiveNode(ew+r[i],i+1,e,false);
                    //printReverse(heap);
                    //取下一个结点
                    HeapNode node=heap.pollLast();
                    i=node.level;
                    e=node.liveNode;
                    ew=node.uweight-r[i-1];
                }

                //输出
                for(int j=0;j&lt;n;j++){
                    bestx[j]=(e.leftChild)?1:0;
                    e=e.parent;
                }
                for(int j=n-1;j&gt;=0;j--){
                    System.out.print(bestx[j]+" ");
                }
                System.out.println();
                return ew;
            }
            public static void main(String[] args) {
                int n=4;
                int c=70;
                int w[]={0,26,60,22,18};//下标从1开始
                int[] bestx=new int[n+1];
                分支界限法_求最大承重问题 b=new 分支界限法_求最大承重问题();
                System.out.println("最优装载顺序为（1表示装入，0表示未装入）：");
                int ew=b.maxLoading(w, c, bestx);
                System.out.println("最优装载重量为："+ew);
            }
        }</code></pre> -->

          </div>

        </div>

        <!--拓展知识模块-->
        <div *ngIf=" MODE == 'advanced'">
          <!--预览模式-->
          <div *ngIf=" TYPE == 'finish'">
            <i nz-icon type="edit" theme="outline" (click)=" TYPE = 'edit'"></i>
            <nz-tabset>
              <nz-tab nzTitle="{{title}}">
                <pre [innerHTML]="preview" ></pre>
              </nz-tab>
            </nz-tabset>
          </div>
          <!--编辑模式-->
          <div *ngIf=" TYPE == 'edit'">
            <i nz-icon type="save" theme="twotone" (click)="TYPE = 'finish'"></i>
            <nz-tabset>
              <nz-tab nzTitle="Write">
                <nz-mention [nzSuggestions]="suggestions">
          <textarea
            nz-input
            [nzAutosize]="{ minRows: 20, maxRows: 20 }"
            [(ngModel)]="inputValue"
            (ngModelChange)="renderPreView()"
            nzMentionTrigger
          >
          </textarea>
                </nz-mention>
              </nz-tab>
              <nz-tab nzTitle="Preview">
                <pre [innerHTML]="preview"></pre>
              </nz-tab>
            </nz-tabset>
          </div>

        </div>

        <!--集合框架-->
        <div *ngIf="MODE == 'fundament'">
          <!--java简介-->
          <div *ngIf=" Sider == '1'">

            <h1>Java简介</h1>
            <nz-timeline>
              <div>
                <video src="../../assets/209.mp4" controls="controls" type="video/mp4"></video>
              </div>
            </nz-timeline>
          </div>

          <!--java发展历史-->
          <div *ngIf="Sider == '2'">
            <!--<nz-content style="background: #ffffff; padding: 24px; min-height: 650px; width: inherit;">-->
            <h1>Java发展历史</h1>
            <nz-timeline [nzPending]="'Recording...'">
              <nz-timeline-item>1995年5月23日，Java语言诞生</nz-timeline-item>
              <nz-timeline-item>1997年2月18日，JDK1.1发布</nz-timeline-item>
              <nz-timeline-item>2000年5月8日，JDK1.3发布</nz-timeline-item>
              <nz-timeline-item>2006年12月，SUN公司发布JRE6.0</nz-timeline-item>
              <nz-timeline-item>2009年04月20日，甲骨文74亿美元收购Sun。取得java的版权</nz-timeline-item>
              <nz-timeline-item>2014年3月18日，Oracle公司发表Java SE 8</nz-timeline-item>
              <ng-template #pending>
                <a>See more</a>
              </ng-template>
            </nz-timeline>
          </div>

          <!--java对象和类-->
          <div *ngIf="Sider == '3'">
            <h1>Java对象和类</h1>
          </div>

          <!--java基本数据类型-->
          <div *ngIf="Sider == '4'">
            <h1>Java基本数据类型</h1>
            <nz-timeline>
              <nz-timeline-item>byte 数据类型是8位、有符号的，以二进制补码表示的整数；</nz-timeline-item>
              <nz-timeline-item>short 数据类型是 16 位、有符号的以二进制补码表示的整数</nz-timeline-item>
              <nz-timeline-item>int 数据类型是32位、有符号的以二进制补码表示的整数；</nz-timeline-item>
              <nz-timeline-item>long 数据类型是 64 位、有符号的以二进制补码表示的整数；</nz-timeline-item>
              <nz-timeline-item>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；</nz-timeline-item>
              <nz-timeline-item>double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；</nz-timeline-item>
              <nz-timeline-item>boolean数据类型表示一位的信息；</nz-timeline-item>
              <nz-timeline-item>char类型是一个单一的 16 位 Unicode 字符；</nz-timeline-item>
            </nz-timeline>
          </div>

          <!--java变量类型-->
          <div *ngIf="Sider == '5'">
            <h1>Java变量类型</h1>
            <nz-timeline>
              <nz-timeline-item>局部变量声明在方法、构造方法或者语句块中；</nz-timeline-item>
              <nz-timeline-item>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</nz-timeline-item>
              <nz-timeline-item>访问修饰符不能用于局部变量；</nz-timeline-item>
              <nz-timeline-item>局部变量只在声明它的方法、构造方法或者语句块中可见；</nz-timeline-item>
              <nz-timeline-item>局部变量是在栈上分配的。</nz-timeline-item>
              <nz-timeline-item>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</nz-timeline-item>
            </nz-timeline>
          </div>

          <!--java修饰符-->
          <div *ngIf="Sider == '6'">
            <h1>Java修饰符</h1>
            <nz-timeline>
              <nz-timeline-item>修饰符用来定义类、方法或者变量，通常放在语句的最前端。</nz-timeline-item>
              <nz-timeline-item>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</nz-timeline-item>
              <nz-timeline-item>default (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</nz-timeline-item>
              <nz-timeline-item>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</nz-timeline-item>
              <nz-timeline-item>public : 对所有类可见。使用对象：类、接口、变量、方法</nz-timeline-item>
              <nz-timeline-item>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</nz-timeline-item>
            </nz-timeline>
          </div>

          <!--java运算符-->
          <div *ngIf="Sider == '7'">
            <h1>Java运算符</h1>
            <nz-timeline>
              <nz-timeline-item>算术运算符：用在数学表达式中，它们的作用和在数学中的作用一样。</nz-timeline-item>
              <nz-timeline-item>自增（++）自减（--）运算符是一种特殊的算术运算符，在算术运算符中需要两个操作数来进行运算，而自增自减运算符是一个操作数。</nz-timeline-item>
              <nz-timeline-item>位运算符：应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。</nz-timeline-item>
              <nz-timeline-item>Java运算符优先级：</nz-timeline-item>
              <nz-timeline-item>当多个运算符出现在一个表达式中，谁先谁后呢？这就涉及到运算符的优先级别的问题。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大。</nz-timeline-item>
              <nz-timeline-item>例如，（1+3）＋（3+2）*2，这个表达式如果按加号最优先计算，答案就是 18，如果按照乘号最优先，答案则是 14。
                再如，x = 7 + 3 * 2;这里x得到13，而不是20，因为乘法运算符比加法运算符有较高的优先级，所以先计算3 * 2得到6，然后再加7。</nz-timeline-item>
            </nz-timeline>
          </div>

          <!--java循环结构-->
          <div *ngIf="Sider == '8'">
            <h1>Java循环结构</h1>
            <nz-timeline>
              <nz-timeline-item>while 循环</nz-timeline-item>
              <nz-timeline-item>do…while 循环</nz-timeline-item>
              <nz-timeline-item>for 循环</nz-timeline-item>
            </nz-timeline>
          </div>

          <!--java语句结构-->
          <div *ngIf="Sider == '9'">
            <h1>Java语句结构</h1>
            <nz-timeline>
              <nz-timeline-item>if 语句</nz-timeline-item>
              <nz-timeline-item>如果布尔表达式的值为 true，则执行 if 语句中的代码块，否则执行 if 语句块后面的代码</nz-timeline-item>
              <nz-timeline-item>if 语句后面可以跟 else 语句，当 if 语句的布尔表达式值为 false 时，else 语句块会被执行</nz-timeline-item>
              <nz-timeline-item>if...else if...else 语句</nz-timeline-item>
              <nz-timeline-item>使用 if，else if，else 语句的时候，需要注意下面几点：</nz-timeline-item>
              <nz-timeline-item>if 语句至多有 1 个 else 语句，else 语句在所有的 elseif 语句之后</nz-timeline-item>
              <nz-timeline-item>if 语句可以有若干个 elseif 语句，它们必须在 else 语句之前</nz-timeline-item>
              <nz-timeline-item>一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行</nz-timeline-item>
            </nz-timeline>
          </div>
        </div>

        <!--相关资源模块-->
        <div *ngIf=" MODE == 'resource'">
          <nz-breadcrumb>
            <nz-breadcrumb-item><a  (click)="getTheResource('all')">All Resource</a></nz-breadcrumb-item>
            <nz-breadcrumb-item *ngIf="this.user.type === 'teacher' || this.user.type === 'admin'"><a (click)="getTheResource('my')">My Resource</a></nz-breadcrumb-item>
          </nz-breadcrumb>


          <nz-drawer [nzClosable]="false" [nzVisible]="visible" nzPlacement="right" nzTitle="上传信息表"  (nzOnClose)="close()">
            <form>
              <div nz-col nzSpan="18">
                <label>作者：</label>
                <input type="text" nz-input [(ngModel)]="author" name="author" />
              </div>
              <div nz-col nzSpan="18">
                <label>资源名称</label>
                <input type="text" nz-input [(ngModel)]="resourceName" name="resourceName" />
              </div>
              <div nz-col nzSpan="18">
                <label>模块属于</label>
                <nz-radio-group [(ngModel)]="theModelName" [ngModelOptions]="{standalone: true}">
                  <label nz-radio nzValue='知识点'>知识点</label>
                  <label nz-radio nzValue='java工具'>java工具</label>
                </nz-radio-group>
              </div>
            </form>
            <nz-upload
              nzAction="http://localhost:8080/upload/"
              [nzName]="fileName"
              [nzCustomRequest]="customReq">
              <button nz-button>
                <i nz-icon type="upload"></i><span>Click to Upload</span>
              </button>
            </nz-upload>
            <div class="footer">
              <button type="button" (click)="close()" class="ant-btn" style="margin-right: 8px;"><span>Cancel</span></button>
              <button type="button" (click)="upload()" class="ant-btn ant-btn-primary"><span>Submit</span></button>
            </div>
          </nz-drawer>

          <nz-table #basicTable [nzData]="theResource" [nzLoading]="loading">
            <thead>
            <tr>
              <th>Author</th>
              <th>ResourceName</th>
              <th>modelName</th>
              <th>Action</th>
            </tr>
            </thead>
            <tbody>
            <tr *ngFor="let data of basicTable.data">
              <td>{{data.author}}</td>
              <td>{{data.resourcename}}</td>
              <td>{{data.type}}</td>
              <td><a href="http://localhost:8080/download?fileName={{data.url}}" ><i nz-icon type="download" theme="outline"></i></a></td>
            </tr>
            </tbody>
          </nz-table>

          <div>

          </div>
        </div>

        <!--在线测试模块-->
        <div *ngIf="MODE =='exam'">
          <!--切换编辑模式-->
          <div *ngIf="this.user.type === 'teacher' || this.user.type === 'admin'">
          <label>编辑模式：</label>
          <nz-switch [(ngModel)]="isEdit" nzCheckedChildren="开" nzUnCheckedChildren="关"></nz-switch>
          </div>
          <!--exam-->
          <div *ngIf="isEdit">
            <nz-breadcrumb>
              <nz-breadcrumb-item>
                <a (click)="CHOOSE='exam'">题目管理</a>
              </nz-breadcrumb-item>
              <nz-breadcrumb-item>
                <a (click)="CHOOSE='test'">试卷管理</a>
              </nz-breadcrumb-item>
            </nz-breadcrumb>
            <!--exam-->
            <div *ngIf="CHOOSE=='exam'">
            <div>
              <button nz-button [nzType]="'primary'" (click)="showModal()"><span>上传题目</span></button>
              <nz-modal [(nzVisible)]="isVisible" nzTitle="新建题目" nzMask="true" (nzOnCancel)="handleCancel()" (nzOnOk)="handleOk()">
                <p>题目：<input [(ngModel)]="examModal.question"/></p>
                <p>题型：<nz-select style="width: 120px;" [(ngModel)]="examModal.type"nzPlaceHolder="Choose">
                        <nz-option nzValue="选择题" nzLabel="选择题"></nz-option>
                        <nz-option nzValue="填空题" nzLabel="填空题"></nz-option>
                        </nz-select></p>
                <p>a选项：   <input [(ngModel)]="examModal.a"/></p>
                <p>b选项：   <input [(ngModel)]="examModal.b"/></p>
                <p>c选项：   <input [(ngModel)]="examModal.c"/></p>
                <p>正确答案：<input [(ngModel)]="examModal.answer"/></p>
                <p>分值：    <input [(ngModel)]="examModal.grade"/></p>
              </nz-modal>
            </div>
            <div style="padding:24px; background: #fff; min-height: 400px;">
              <!--table-->
              <nz-table #nzTable [nzData]="exam" [nzLoading]="loading">
                <thead>
                <tr>
                  <th>题目类型</th>
                  <th >试题分值</th>
                  <th>试题</th>
                  <th>A选项</th>
                  <th>B选项</th>
                  <th>C选项</th>
                </tr>
                </thead>
                <tbody>
                <tr *ngFor="let data of nzTable.data">
                  <td>{{data.type}}</td>
                  <td>{{data.grade}}</td>
                  <td>{{data.question}}</td>
                  <td>{{data.a}}</td>
                  <td>{{data.b}}</td>
                  <td>{{data.c}}</td>
                </tr>
                </tbody>
              </nz-table>
            </div>
            </div>
            <!--testPaper-->
            <div *ngIf="CHOOSE=='test'">
              <div>
                <button nz-button [nzType]="'primary'" (click)="showModal()"><span>新建试卷</span></button>
                <nz-modal [(nzVisible)]="isVisible" nzTitle="新试卷" (nzOnCancel)="handleCancel()" (nzOnOk)="handleOk()">
                  <p>试卷名称：<input [(ngModel)]="examName"/></p>
                  <p>题目<nz-select style="width: 100%" [(ngModel)]="multipleValue" [nzSize]="size" nzMode="multiple" nzPlaceHolder="Please select">
                    <nz-option *ngFor="let option of listOfOption" [nzLabel]="option.label" [nzValue]="option.value"></nz-option>
                  </nz-select></p>
                  <p>难度：<nz-select style="width: 120px;" [(ngModel)]="selectedValue" nzPlaceHolder="Choose">
                    <nz-option nzValue="简单" nzLabel="简单" name=""></nz-option>
                    <nz-option nzValue="中等" nzLabel="中等"></nz-option>
                    <nz-option nzValue="难" nzLabel="难"></nz-option>
                  </nz-select></p>
                  <p>备注：<input [(ngModel)]="remark"/></p>
                </nz-modal>
              </div>
            <div style="padding:24px; background: #fff; min-height: 400px;">
              <!--table-->
              <nz-table #nzPaper [nzData]="testPaperList"  [nzLoading]="loading">
                <thead>
                <tr>
                  <th>作者</th>
                  <th >试卷名称</th>
                  <th>试卷难度</th>
                  <th>备注</th>
                </tr>
                </thead>
                <tbody>
                <tr *ngFor="let data of nzPaper.data">
                  <td>{{data.author}}</td>
                  <td>{{data.name}}</td>
                  <td>{{data.difficulty}}</td>
                  <td>{{data.remark}}</td>
                </tr>
                </tbody>
              </nz-table>

            </div>
          </div>
        </div>
          <div *ngIf="!isEdit">
            <!--选择试卷-->
            <div *ngIf="!isTest">
            <nz-table #nzPaper [nzData]="testPaperList"  [nzLoading]="loading">
              <thead>
              <tr>
                <th>作者</th>
                <th >试卷名称</th>
                <th>试卷难度</th>
                <th>备注</th>
                <th>选择</th>
              </tr>
              </thead>
              <tbody>
              <tr *ngFor="let data of nzPaper.data">
                <td>{{data.author}}</td>
                <td>{{data.name}}</td>
                <td>{{data.difficulty}}</td>
                <td>{{data.remark}}</td>
                <td><a (click)="isTest=true;loading=true;setTheTest(data.id);loading=false"><i nz-icon type="edit" theme="twotone"></i></a></td>
              </tr>
              </tbody>
            </nz-table>
            </div>
            <!--指定试卷-->
            <div *ngIf="isTest">
              <nz-table #nzTable [nzData]="theTest" [nzLoading]="loading" [nzShowPagination]="false">
                <tbody *ngFor="let data of nzTable.data">
                <tr>
                  <td colspan="3">{{data.question}}</td>
                </tr>
                <tr>
                  <nz-radio-group [(ngModel)]="data.answer">
                    <td> <label nz-radio nzValue="A">A{{data.a}}</label></td>
                    <td> <label nz-radio nzValue="B">B{{data.b}}</label></td>
                    <td> <label nz-radio nzValue="C">C{{data.c}}</label></td>
                  </nz-radio-group>
                </tr>
                <br/>
                </tbody>
              </nz-table>
              <button (click)="this.getGrade()">交卷</button>
            </div>
          </div>
        </div>
        <!--修改密码模块-->
        <div >
          <nz-drawer [nzClosable]="false" [nzVisible]="Pvisible" nzPlacement="top" nzTitle="修改密码" (nzOnClose)="close()">
           <p><label>当前用户</label>
            <input value="{{this.user.loginname}}" readonly> </p>
            <p><label>新密码：</label>
            <input [(ngModel)]="this.user.password"> </p>
            <p><button nz-button nzType="primary"  (click)="update()">修改</button></p>
          </nz-drawer>
        </div>
      </nz-content>

    </nz-layout>

  </nz-layout>
